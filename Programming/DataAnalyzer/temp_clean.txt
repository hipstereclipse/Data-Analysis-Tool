#!/usr/bin/env python3
"""
Dialog windows for user interaction - FIXED VERSION WITH LEGACY FEATURES
"""

import tkinter as tk
from datetime import datetime
from tkinter import ttk, messagebox, colorchooser, filedialog
import customtkinter as ctk
from typing import Optional, Dict, List, Any, Callable
import numpy as np
import pandas as pd
from pathlib import Path
import json
import logging

from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
from matplotlib.figure import Figure
import matplotlib.pyplot as plt

from analysis.vacuum import VacuumAnalyzer
from models.data_models import FileData, SeriesConfig, AnnotationConfig
from config.constants import UIConfig, MissingDataMethods, TrendTypes
from ui.components import CollapsibleFrame, ToolTip
from utils.helpers import detect_datetime_column
from scipy.signal import find_peaks, savgol_filter

# Initialize logger
logger = logging.getLogger(__name__)


class SeriesConfigDialog:
    """
    Modern, intuitive series configuration dialog
    Provides comprehensive settings for how data series are displayed
    """

    def __init__(self, parent, series_config, file_data):
        """
        Initialize series configuration dialog

        Args:
            parent: Parent window
            series_config: SeriesConfig object to edit
            file_data: FileData object containing the data
        """
        self.parent = parent
        self.series = series_config
        self.file_data = file_data
        self.result = None

        # Analyze data for smart defaults
        self.analyze_data()

        self.dialog = tk.Toplevel(parent)
        self.dialog.title(f"Configure: {series_config.name}")
        self.dialog.geometry("1050x750")
        self.dialog.configure(bg='#f0f0f0')

        # Modern styling
        self.setup_styles()

        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Store dialog as 'top' for compatibility
        self.top = self.dialog

        self.create_widgets()
        self.dialog.geometry(f"+{parent.winfo_rootx() + 50}+{parent.winfo_rooty() + 50}")

    def setup_styles(self):
        """Configure ttk styles for modern appearance"""
        style = ttk.Style()
        style.theme_use('clam')

        # Configure colors
        style.configure('Title.TLabel', font=('Segoe UI', 12, 'bold'))
        style.configure('Heading.TLabel', font=('Segoe UI', 10, 'bold'))
        style.configure('Success.TButton', foreground='white')
        style.map('Success.TButton', background=[('active', '#059669'), ('!active', '#10B981')])

    def analyze_data(self):
        """Analyze data to provide intelligent defaults"""
        if self.file_data and self.file_data.data is not None:
            df = self.file_data.data

            # Detect datetime columns
            self.datetime_columns = []
            for col in df.columns:
                if pd.api.types.is_datetime64_any_dtype(df[col]):
                    self.datetime_columns.append(col)
                else:
                    # Try to parse as datetime
                    try:
                        pd.to_datetime(df[col], errors='coerce')
                        if df[col].notna().sum() > 0:  # At least some valid dates
                            self.datetime_columns.append(col)
                    except:
                        pass

            # Detect numeric columns
            self.numeric_columns = df.select_dtypes(include=[np.number]).columns.tolist()

            # Calculate data quality metrics
            self.missing_data = df.isnull().sum()
            self.data_ranges = {}
            for col in self.numeric_columns:
                self.data_ranges[col] = {
                    'min': df[col].min(),
                    'max': df[col].max(),
                    'mean': df[col].mean(),
                    'std': df[col].std()
                }

    def create_widgets(self):
        """Create the dialog interface"""
        # Create main notebook
        self.notebook = ttk.Notebook(self.dialog)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Create tabs
        self.create_data_tab()
        self.create_appearance_tab()
        self.create_processing_tab()
        self.create_analysis_tab()
        self.create_preview_tab()

        # Button frame
        btn_frame = ttk.Frame(self.dialog)
        btn_frame.pack(fill='x', padx=10, pady=10)

        ttk.Button(btn_frame, text="Cancel", command=self.cancel).pack(side='right', padx=5)
        ttk.Button(btn_frame, text="Apply", command=self.apply,
                   style='Success.TButton').pack(side='right', padx=5)

        # Load current settings
        self.load_current_settings()

    def create_data_tab(self):
        """Create data selection tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Data Selection")

        # Series name
        name_frame = ttk.LabelFrame(tab, text="Series Identification", padding=10)
        name_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(name_frame, text="Series Name:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.name_var = tk.StringVar(value=self.series.name)
        ttk.Entry(name_frame, textvariable=self.name_var, width=40).grid(row=0, column=1, padx=5, pady=5)

        # Column selection
        col_frame = ttk.LabelFrame(tab, text="Data Columns", padding=10)
        col_frame.pack(fill='x', padx=10, pady=10)

        # X Column with smart suggestions
        ttk.Label(col_frame, text="X Column:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.x_col_var = tk.StringVar(value=self.series.x_column)
        x_combo = ttk.Combobox(col_frame, textvariable=self.x_col_var, width=30)
        x_combo['values'] = list(self.file_data.data.columns)
        x_combo.grid(row=0, column=1, padx=5, pady=5)

        # Suggest datetime columns for X
        if self.datetime_columns:
            suggest_btn = ttk.Button(col_frame, text="Suggest Time",
                                     command=lambda: self.x_col_var.set(self.datetime_columns[0]))
            suggest_btn.grid(row=0, column=2, padx=5, pady=5)

        # Y Column
        ttk.Label(col_frame, text="Y Column:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.y_col_var = tk.StringVar(value=self.series.y_column)
        y_combo = ttk.Combobox(col_frame, textvariable=self.y_col_var, width=30)
        y_combo['values'] = list(self.file_data.data.columns)
        y_combo.grid(row=1, column=1, padx=5, pady=5)

        # Data range selection
        range_frame = ttk.LabelFrame(tab, text="Data Range", padding=10)
        range_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(range_frame, text="Start Row:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.start_var = tk.StringVar(value=str(self.series.start_row) if self.series.start_row else "")
        start_entry = ttk.Entry(range_frame, textvariable=self.start_var, width=15)
        start_entry.grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(range_frame, text="End Row:").grid(row=0, column=2, sticky='w', padx=20, pady=5)
        self.end_var = tk.StringVar(value=str(self.series.end_row) if self.series.end_row else "")
        end_entry = ttk.Entry(range_frame, textvariable=self.end_var, width=15)
        end_entry.grid(row=0, column=3, padx=5, pady=5)

        # Quick range buttons
        btn_frame = ttk.Frame(range_frame)
        btn_frame.grid(row=1, column=0, columnspan=4, pady=10)

        ttk.Button(btn_frame, text="First 100",
                   command=lambda: self.set_range(1, 100)).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="First 1000",
                   command=lambda: self.set_range(1, 1000)).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="All Data",
                   command=lambda: self.set_range("", "")).pack(side='left', padx=5)
        ttk.Button(btn_frame, text="Last 100",
                   command=lambda: self.set_range(-100, "")).pack(side='left', padx=5)

        # Data quality info
        quality_frame = ttk.LabelFrame(tab, text="Data Quality", padding=10)
        quality_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Create treeview for data quality
        quality_tree = ttk.Treeview(quality_frame, columns=('Value',), height=6)
        quality_tree.heading('#0', text='Metric')
        quality_tree.heading('Value', text='Value')
        quality_tree.pack(fill='both', expand=True)

        # Add quality metrics
        if hasattr(self, 'missing_data'):
            for col in [self.series.x_column, self.series.y_column]:
                if col and col in self.missing_data.index:
                    quality_tree.insert('', 'end', text=f"{col} Missing",
                                        values=(f"{self.missing_data[col]} values",))

    def create_appearance_tab(self):
        """Create appearance settings tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Appearance")

        # Plot type
        type_frame = ttk.LabelFrame(tab, text="Plot Type", padding=10)
        type_frame.pack(fill='x', padx=10, pady=10)

        self.plot_type_var = tk.StringVar(value=self.series.plot_type)

        # Create radio buttons for plot types
        plot_types = [
            ("Line", "line"),
            ("Scatter", "scatter"),
            ("Line + Markers", "both"),
            ("Bar", "bar"),
            ("Area", "area"),
            ("Step", "step")
        ]

        for i, (label, value) in enumerate(plot_types):
            ttk.Radiobutton(type_frame, text=label, variable=self.plot_type_var,
                            value=value).grid(row=i // 3, column=i % 3, padx=10, pady=5, sticky='w')

        # Line style
        line_frame = ttk.LabelFrame(tab, text="Line Properties", padding=10)
        line_frame.pack(fill='x', padx=10, pady=10)

        # Color
        ttk.Label(line_frame, text="Color:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.color_var = tk.StringVar(value=self.series.color)
        self.color_button = tk.Button(line_frame, text="    ", bg=self.series.color,
                                      command=self.choose_color)
        self.color_button.grid(row=0, column=1, padx=5, pady=5)
        self.color_label = ttk.Label(line_frame, text=self.series.color)
        self.color_label.grid(row=0, column=2, padx=5, pady=5)

        # Line style
        ttk.Label(line_frame, text="Line Style:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.line_style_var = tk.StringVar(value=self.series.line_style)
        style_combo = ttk.Combobox(line_frame, textvariable=self.line_style_var, width=15)
        style_combo['values'] = ["-", "--", ":", "-.", ""]
        style_combo.grid(row=1, column=1, columnspan=2, padx=5, pady=5, sticky='w')

        # Line width
        ttk.Label(line_frame, text="Line Width:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.line_width_var = tk.DoubleVar(value=self.series.line_width)
        width_scale = ttk.Scale(line_frame, from_=0.5, to=5.0, variable=self.line_width_var,
                                orient='horizontal', length=200)
        width_scale.grid(row=2, column=1, columnspan=2, padx=5, pady=5)
        self.width_label = ttk.Label(line_frame, text=f"{self.series.line_width:.1f}")
        self.width_label.grid(row=2, column=3, padx=5, pady=5)

        # Update label when scale changes
        width_scale.configure(command=lambda v: self.width_label.config(text=f"{float(v):.1f}"))

        # Marker style
        marker_frame = ttk.LabelFrame(tab, text="Marker Properties", padding=10)
        marker_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(marker_frame, text="Marker Style:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.marker_style_var = tk.StringVar(value=self.series.marker_style)
        marker_combo = ttk.Combobox(marker_frame, textvariable=self.marker_style_var, width=15)
        marker_combo['values'] = ["", "o", "s", "^", "v", "D", "*", "+", "x", "."]
        marker_combo.grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(marker_frame, text="Marker Size:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.marker_size_var = tk.DoubleVar(value=self.series.marker_size)
        size_scale = ttk.Scale(marker_frame, from_=1, to=20, variable=self.marker_size_var,
                               orient='horizontal', length=200)
        size_scale.grid(row=1, column=1, padx=5, pady=5)
        self.size_label = ttk.Label(marker_frame, text=f"{self.series.marker_size:.1f}")
        self.size_label.grid(row=1, column=2, padx=5, pady=5)

        size_scale.configure(command=lambda v: self.size_label.config(text=f"{float(v):.1f}"))

        # Transparency
        ttk.Label(marker_frame, text="Transparency:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.alpha_var = tk.DoubleVar(value=self.series.alpha)
        alpha_scale = ttk.Scale(marker_frame, from_=0.1, to=1.0, variable=self.alpha_var,
                                orient='horizontal', length=200)
        alpha_scale.grid(row=2, column=1, padx=5, pady=5)
        self.alpha_label = ttk.Label(marker_frame, text=f"{self.series.alpha:.2f}")
        self.alpha_label.grid(row=2, column=2, padx=5, pady=5)

        alpha_scale.configure(command=lambda v: self.alpha_label.config(text=f"{float(v):.2f}"))

    def create_processing_tab(self):
        """Create data processing tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Data Processing")

        # Missing data handling
        missing_frame = ttk.LabelFrame(tab, text="Missing Data Handling", padding=10)
        missing_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(missing_frame, text="Method:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.missing_method_var = tk.StringVar(value=self.series.missing_data_method)
        method_combo = ttk.Combobox(missing_frame, textvariable=self.missing_method_var, width=20)
        method_combo['values'] = ["drop", "interpolate", "forward", "backward", "zero", "mean"]
        method_combo.grid(row=0, column=1, padx=5, pady=5)

        # Add tooltips for methods
        ToolTip(method_combo, "drop: Remove missing values\n"
                              "interpolate: Linear interpolation\n"
                              "forward: Use previous value\n"
                              "backward: Use next value\n"
                              "zero: Fill with zeros\n"
                              "mean: Fill with column mean")

        # Smoothing
        smooth_frame = ttk.LabelFrame(tab, text="Data Smoothing", padding=10)
        smooth_frame.pack(fill='x', padx=10, pady=10)

        self.smoothing_var = tk.BooleanVar(value=self.series.smoothing)
        smooth_check = ttk.Checkbutton(smooth_frame, text="Apply Smoothing",
                                       variable=self.smoothing_var,
                                       command=self.toggle_smoothing)
        smooth_check.grid(row=0, column=0, padx=5, pady=5)

        ttk.Label(smooth_frame, text="Window Size:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.smooth_factor_var = tk.IntVar(value=self.series.smooth_factor)
        self.smooth_scale = ttk.Scale(smooth_frame, from_=3, to=51, variable=self.smooth_factor_var,
                                      orient='horizontal', length=200)
        self.smooth_scale.grid(row=1, column=1, padx=5, pady=5)
        self.smooth_label = ttk.Label(smooth_frame, text=str(self.series.smooth_factor))
        self.smooth_label.grid(row=1, column=2, padx=5, pady=5)

        # Only odd numbers for Savitzky-Golay
        def update_smooth(v):
            val = int(float(v))
            if val % 2 == 0:
                val += 1
            self.smooth_factor_var.set(val)
            self.smooth_label.config(text=str(val))

        self.smooth_scale.configure(command=update_smooth)

        # Enable/disable based on checkbox
        self.toggle_smoothing()

        # Advanced processing
        advanced_frame = ttk.LabelFrame(tab, text="Advanced Processing", padding=10)
        advanced_frame.pack(fill='x', padx=10, pady=10)

        # Y-axis selection
        ttk.Label(advanced_frame, text="Y-Axis:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.y_axis_var = tk.StringVar(value=self.series.y_axis)
        axis_combo = ttk.Combobox(advanced_frame, textvariable=self.y_axis_var, width=10)
        axis_combo['values'] = ["left", "right"]
        axis_combo.grid(row=0, column=1, padx=5, pady=5)

        # Z-order
        ttk.Label(advanced_frame, text="Z-Order:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.z_order_var = tk.IntVar(value=self.series.z_order)
        z_spin = ttk.Spinbox(advanced_frame, from_=0, to=100, textvariable=self.z_order_var, width=10)
        z_spin.grid(row=1, column=1, padx=5, pady=5)

        ToolTip(z_spin, "Higher values are drawn on top")

    def create_analysis_tab(self):
        """Create analysis options tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Analysis")

        # Trend line
        trend_frame = ttk.LabelFrame(tab, text="Trend Line", padding=10)
        trend_frame.pack(fill='x', padx=10, pady=10)

        self.show_trend_var = tk.BooleanVar(value=self.series.show_trend)
        trend_check = ttk.Checkbutton(trend_frame, text="Show Trend Line",
                                      variable=self.show_trend_var,
                                      command=self.toggle_trend)
        trend_check.grid(row=0, column=0, padx=5, pady=5)

        ttk.Label(trend_frame, text="Type:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.trend_type_var = tk.StringVar(value=self.series.trend_type)
        self.trend_combo = ttk.Combobox(trend_frame, textvariable=self.trend_type_var, width=20)
        self.trend_combo['values'] = ["linear", "polynomial", "exponential", "logarithmic", "moving_average"]
        self.trend_combo.grid(row=1, column=1, padx=5, pady=5)

        ttk.Label(trend_frame, text="Color:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.trend_color_var = tk.StringVar(value=self.series.trend_color or "")
        self.trend_color_button = tk.Button(trend_frame, text="Auto" if not self.series.trend_color else "    ",
                                            bg=self.series.trend_color if self.series.trend_color else "#999999",
                                            command=self.choose_trend_color)
        self.trend_color_button.grid(row=2, column=1, padx=5, pady=5, sticky='w')

        # Enable/disable based on checkbox
        self.toggle_trend()

        # Statistics
        stats_frame = ttk.LabelFrame(tab, text="Statistical Overlays", padding=10)
        stats_frame.pack(fill='x', padx=10, pady=10)

        self.show_mean_var = tk.BooleanVar(value=self.series.show_mean)
        ttk.Checkbutton(stats_frame, text="Show Mean Line",
                        variable=self.show_mean_var).grid(row=0, column=0, padx=5, pady=5, sticky='w')

        self.show_std_var = tk.BooleanVar(value=self.series.show_std)
        ttk.Checkbutton(stats_frame, text="Show Standard Deviation Bands",
                        variable=self.show_std_var).grid(row=1, column=0, padx=5, pady=5, sticky='w')

    def create_preview_tab(self):
        """Create preview tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Preview")

        # Create matplotlib figure for preview
        self.preview_figure = Figure(figsize=(8, 6), dpi=80)
        self.preview_ax = self.preview_figure.add_subplot(111)

        # Create canvas
        self.preview_canvas = FigureCanvasTkAgg(self.preview_figure, master=tab)
        self.preview_canvas.get_tk_widget().pack(fill='both', expand=True, padx=10, pady=10)

        # Update button
        btn_frame = ttk.Frame(tab)
        btn_frame.pack(fill='x', padx=10, pady=5)

        ttk.Button(btn_frame, text="Update Preview", command=self.update_preview).pack(side='right', padx=5)

        # Initial preview
        self.update_preview()

    def toggle_smoothing(self):
        """Enable/disable smoothing controls"""
        state = 'normal' if self.smoothing_var.get() else 'disabled'
        self.smooth_scale.configure(state=state)

    def toggle_trend(self):
        """Enable/disable trend controls"""
        state = 'normal' if self.show_trend_var.get() else 'disabled'
        self.trend_combo.configure(state=state)
        self.trend_color_button.configure(state=state)

    def choose_color(self):
        """Open color chooser for line color"""
        color = colorchooser.askcolor(initialcolor=self.color_var.get())
        if color[1]:
            self.color_var.set(color[1])
            self.color_button.configure(bg=color[1])
            self.color_label.configure(text=color[1])

    def choose_trend_color(self):
        """Open color chooser for trend line color"""
        color = colorchooser.askcolor(initialcolor=self.trend_color_var.get() or self.color_var.get())
        if color[1]:
            self.trend_color_var.set(color[1])
            self.trend_color_button.configure(bg=color[1], text="    ")

    def set_range(self, start, end):
        """Set data range quickly"""
        self.start_var.set(str(start) if start else "")
        self.end_var.set(str(end) if end else "")

    def update_preview(self):
        """Update the preview plot"""
        try:
            # Clear previous plot
            self.preview_ax.clear()

            # Get current settings
            x_col = self.x_col_var.get()
            y_col = self.y_col_var.get()

            if not x_col or not y_col:
                self.preview_ax.text(0.5, 0.5, "Select X and Y columns",
                                     ha='center', va='center', transform=self.preview_ax.transAxes)
                self.preview_canvas.draw()
                return

            # Get data
            df = self.file_data.data

            # Apply range
            start = int(self.start_var.get()) if self.start_var.get() else None
            end = int(self.end_var.get()) if self.end_var.get() else None

            if start is not None or end is not None:
                df = df.iloc[start:end]

            x_data = df[x_col]
            y_data = df[y_col]

            # Apply missing data handling
            method = self.missing_method_var.get()
            if method == "drop":
                mask = y_data.notna()
                x_data = x_data[mask]
                y_data = y_data[mask]
            elif method == "interpolate":
                y_data = y_data.interpolate()
            elif method == "forward":
                y_data = y_data.fillna(method='ffill')
            elif method == "backward":
                y_data = y_data.fillna(method='bfill')
            elif method == "zero":
                y_data = y_data.fillna(0)
            elif method == "mean":
                y_data = y_data.fillna(y_data.mean())

            # Apply smoothing if enabled
            if self.smoothing_var.get() and len(y_data) > self.smooth_factor_var.get():
                from scipy.signal import savgol_filter
                window = min(self.smooth_factor_var.get(), len(y_data))
                if window % 2 == 0:
                    window -= 1
                y_data = savgol_filter(y_data, window, 3)

            # Plot based on type
            plot_type = self.plot_type_var.get()
            color = self.color_var.get()

            if plot_type == "line":
                self.preview_ax.plot(x_data, y_data, color=color,
                                     linestyle=self.line_style_var.get(),
                                     linewidth=self.line_width_var.get(),
                                     alpha=self.alpha_var.get())
            elif plot_type == "scatter":
                self.preview_ax.scatter(x_data, y_data, color=color,
                                        marker=self.marker_style_var.get() or 'o',
                                        s=self.marker_size_var.get() ** 2,
                                        alpha=self.alpha_var.get())
            elif plot_type == "both":
                self.preview_ax.plot(x_data, y_data, color=color,
                                     linestyle=self.line_style_var.get(),
                                     linewidth=self.line_width_var.get(),
                                     marker=self.marker_style_var.get() or 'o',
                                     markersize=self.marker_size_var.get(),
                                     alpha=self.alpha_var.get())

            # Add trend line if enabled
            if self.show_trend_var.get():
                self.add_trend_line(x_data, y_data)

            # Add statistics if enabled
            if self.show_mean_var.get():
                mean_val = y_data.mean()
                self.preview_ax.axhline(mean_val, color='red', linestyle='--', alpha=0.5, label=f'Mean: {mean_val:.2f}')

            if self.show_std_var.get():
                mean_val = y_data.mean()
                std_val = y_data.std()
                self.preview_ax.axhline(mean_val + std_val, color='orange', linestyle=':', alpha=0.3)
                self.preview_ax.axhline(mean_val - std_val, color='orange', linestyle=':', alpha=0.3)
                self.preview_ax.fill_between(x_data, mean_val - std_val, mean_val + std_val,
                                             color='orange', alpha=0.1)

            # Set labels
            self.preview_ax.set_xlabel(x_col)
            self.preview_ax.set_ylabel(y_col)
            self.preview_ax.set_title(self.name_var.get())
            self.preview_ax.grid(True, alpha=0.3)

            if self.show_mean_var.get():
                self.preview_ax.legend()

            self.preview_canvas.draw()

        except Exception as e:
            self.preview_ax.clear()
            self.preview_ax.text(0.5, 0.5, f"Error: {str(e)}",
                                 ha='center', va='center', transform=self.preview_ax.transAxes,
                                 color='red')
            self.preview_canvas.draw()

    def add_trend_line(self, x_data, y_data):
        """Add trend line to preview"""
        try:
            # Convert to numeric if needed
            if hasattr(x_data, 'values'):
                x_vals = np.arange(len(x_data))
            else:
                x_vals = np.arange(len(x_data))

            y_vals = y_data.values if hasattr(y_data, 'values') else y_data

            # Remove NaN values
            mask = ~np.isnan(y_vals)
            x_vals = x_vals[mask]
            y_vals = y_vals[mask]

            if len(x_vals) < 2:
                return

            trend_type = self.trend_type_var.get()
            trend_color = self.trend_color_var.get() or self.color_var.get()

            if trend_type == "linear":
                # Linear regression
                z = np.polyfit(x_vals, y_vals, 1)
                p = np.poly1d(z)
                self.preview_ax.plot(x_data, p(x_vals), '--', color=trend_color, alpha=0.7,
                                     label=f'Linear: y={z[0]:.2e}x+{z[1]:.2f}')

            elif trend_type == "polynomial":
                # Polynomial fit (degree 2)
                z = np.polyfit(x_vals, y_vals, 2)
                p = np.poly1d(z)
                self.preview_ax.plot(x_data, p(x_vals), '--', color=trend_color, alpha=0.7,
                                     label='Polynomial (2nd degree)')

            elif trend_type == "moving_average":
                # Moving average
                window = min(20, len(y_vals) // 4)
                ma = pd.Series(y_vals).rolling(window=window, center=True).mean()
                self.preview_ax.plot(x_data, ma, '--', color=trend_color, alpha=0.7,
                                     label=f'Moving Avg (window={window})')

            self.preview_ax.legend()

        except Exception as e:
            print(f"Trend line error: {e}")

    def load_current_settings(self):
        """Load current series settings into the dialog"""
        # Already done through variable initialization
        pass

    def apply(self):
        """Apply the configuration changes"""
        # Update series object
        self.series.name = self.name_var.get()
        self.series.x_column = self.x_col_var.get()
        self.series.y_column = self.y_col_var.get()

        # Data range
        self.series.start_row = int(self.start_var.get()) if self.start_var.get() else None
        self.series.end_row = int(self.end_var.get()) if self.end_var.get() else None

        # Appearance
        self.series.color = self.color_var.get()
        self.series.line_style = self.line_style_var.get()
        self.series.line_width = self.line_width_var.get()
        self.series.marker_style = self.marker_style_var.get()
        self.series.marker_size = self.marker_size_var.get()
        self.series.alpha = self.alpha_var.get()
        self.series.plot_type = self.plot_type_var.get()

        # Processing
        self.series.missing_data_method = self.missing_method_var.get()
        self.series.smoothing = self.smoothing_var.get()
        self.series.smooth_factor = self.smooth_factor_var.get()

        # Analysis
        self.series.show_trend = self.show_trend_var.get()
        self.series.trend_type = self.trend_type_var.get()
        self.series.trend_color = self.trend_color_var.get() if self.trend_color_var.get() else None
        self.series.show_mean = self.show_mean_var.get()
        self.series.show_std = self.show_std_var.get()

        # Advanced
        self.series.y_axis = self.y_axis_var.get()
        self.series.z_order = self.z_order_var.get()

        self.result = "apply"
        self.dialog.destroy()

    def cancel(self):
        """Cancel without applying changes"""
        self.result = "cancel"
        self.dialog.destroy()


class SeriesDialog:
    """Dialog for creating/editing data series - Enhanced with Legacy Features"""

    def __init__(
            self,
            parent,
            files: Dict[str, FileData],
            series: Optional[SeriesConfig] = None,
            mode: str = "create"
    ):
        self.parent = parent
        self.files = files
        self.series = series
        self.mode = mode
        self.result = None

        # Create dialog
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Create Series" if mode == "create" else "Edit Series")
        self.dialog.geometry("1200x800")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Initialize variables
        self._init_variables()

        # Create UI
        self._create_widgets()

        # Initialize file selection AFTER widgets are created
        if self.files:
            file_names = [f.filename for f in self.files.values()]
            if file_names:
                self.file_var.set(file_names[0])
                self._on_file_change(file_names[0])

        # Load existing values if editing
        if mode == "edit" and series:
            self._load_series_config()

        # Center dialog
        self._center_dialog()

        # Initial preview
        self._update_preview()

    def _init_variables(self):
        """Initialize dialog variables"""
        self.name_var = tk.StringVar(value="New Series" if not self.series else self.series.name)
        self.file_var = tk.StringVar()
        self.x_column_var = tk.StringVar()
        self.y_column_var = tk.StringVar()
        self.start_var = tk.IntVar(value=0)
        self.end_var = tk.IntVar(value=0)

        # Visual properties
        self.color_var = tk.StringVar(value="#3B82F6")
        self.line_style_var = tk.StringVar(value="-")
        self.line_width_var = tk.DoubleVar(value=1.5)
        self.marker_var = tk.StringVar(value="")
        self.marker_size_var = tk.IntVar(value=6)
        self.alpha_var = tk.DoubleVar(value=1.0)

        # Options
        self.visible_var = tk.BooleanVar(value=True)
        self.show_legend_var = tk.BooleanVar(value=True)
        self.missing_method_var = tk.StringVar(value="drop")
        self.smoothing_var = tk.BooleanVar(value=False)
        self.smoothing_window_var = tk.IntVar(value=5)

        # Trend line
        self.show_trend_var = tk.BooleanVar(value=False)
        self.trend_type_var = tk.StringVar(value="linear")
        self.trend_order_var = tk.IntVar(value=2)

        # Analysis
        self.show_stats_var = tk.BooleanVar(value=False)
        self.show_peaks_var = tk.BooleanVar(value=False)
        self.peak_prominence_var = tk.DoubleVar(value=0.1)

        # Legacy properties
        self.z_order_var = tk.IntVar(value=0)
        self.plot_type_var = tk.StringVar(value="line")

    def _create_widgets(self):
        """Create dialog widgets with legacy enhancements"""
        # Main container
        main_frame = ttk.Frame(self.dialog)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Left panel - Configuration
        left_panel = ctk.CTkScrollableFrame(main_frame, width=400)
        left_panel.pack(side="left", fill="y", padx=(0, 10))

        # Right panel - Preview
        right_panel = ctk.CTkFrame(main_frame)
        right_panel.pack(side="right", fill="both", expand=True)

        # Create ALL sections first - this ensures all widgets exist
        self._create_basic_section(left_panel)
        self._create_data_section(left_panel)
        self._create_visual_section(left_panel)
        self._create_processing_section(left_panel)
        self._create_analysis_section(left_panel)
        self._create_legacy_section(left_panel)  # New legacy section

        # Create preview
        self._create_preview_panel(right_panel)

        # Buttons
        self._create_buttons()

    def _create_basic_section(self, parent):
        """Create basic configuration section"""
        section = CollapsibleFrame(parent, "Basic Settings")
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # Series name
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Name:", width=100).pack(side="left")
        ctk.CTkEntry(frame, textvariable=self.name_var, width=200).pack(side="left", padx=5)

        # File selection - DON'T call _on_file_change here yet
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="File:", width=100).pack(side="left")

        file_names = [f.filename for f in self.files.values()]
        file_combo = ctk.CTkComboBox(
            frame,
            variable=self.file_var,
            values=file_names,
            width=200,
            command=self._on_file_change
        )
        file_combo.pack(side="left", padx=5)

    def _create_data_section(self, parent):
        """Create data selection section"""
        section = CollapsibleFrame(parent, "Data Selection")
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # X column
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="X Column:", width=100).pack(side="left")
        self.x_combo = ctk.CTkComboBox(
            frame,
            variable=self.x_column_var,
            values=["Index"],  # Default value
            width=200,
            command=lambda e: self._update_preview()
        )
        self.x_combo.pack(side="left", padx=5)

        # Y column
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Y Column:", width=100).pack(side="left")
        self.y_combo = ctk.CTkComboBox(
            frame,
            variable=self.y_column_var,
            values=[],  # Will be populated when file is selected
            width=200,
            command=lambda e: self._update_preview()
        )
        self.y_combo.pack(side="left", padx=5)

        # Data range
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Range:").pack(side="left", padx=5)

        # Start index
        ctk.CTkLabel(frame, text="Start:").pack(side="left", padx=5)
        self.start_slider = ctk.CTkSlider(
            frame,
            from_=0,
            to=1000,
            variable=self.start_var,
            width=100,
            command=lambda v: self._update_range()
        )
        self.start_slider.pack(side="left", padx=5)
        self.start_label = ctk.CTkLabel(frame, text="0")
        self.start_label.pack(side="left")

        # End index
        ctk.CTkLabel(frame, text="End:").pack(side="left", padx=5)
        self.end_slider = ctk.CTkSlider(
            frame,
            from_=0,
            to=1000,
            variable=self.end_var,
            width=100,
            command=lambda v: self._update_range()
        )
        self.end_slider.pack(side="left", padx=5)
        self.end_label = ctk.CTkLabel(frame, text="0")
        self.end_label.pack(side="left")

    def _create_visual_section(self, parent):
        """Create visual properties section"""
        section = CollapsibleFrame(parent, "Visual Properties", collapsed=True)
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # Color
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Color:", width=100).pack(side="left")
        self.color_button = ctk.CTkButton(
            frame,
            text="",
            width=30,
            height=30,
            fg_color=self.color_var.get(),
            command=self._choose_color
        )
        self.color_button.pack(side="left", padx=5)
        ctk.CTkLabel(frame, textvariable=self.color_var).pack(side="left", padx=5)

        # Line style
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Line Style:", width=100).pack(side="left")
        ctk.CTkComboBox(
            frame,
            variable=self.line_style_var,
            values=["-", "--", ":", "-."],
            width=100,
            command=lambda e: self._update_preview()
        ).pack(side="left", padx=5)

        # Line width
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Line Width:", width=100).pack(side="left")
        ctk.CTkSlider(
            frame,
            from_=0.5,
            to=5,
            variable=self.line_width_var,
            width=150,
            command=lambda v: self._update_preview()
        ).pack(side="left", padx=5)

        # Marker
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Marker:", width=100).pack(side="left")
        ctk.CTkComboBox(
            frame,
            variable=self.marker_var,
            values=["", "o", "s", "^", "v", "D", "*", "+", "x"],
            width=100,
            command=lambda e: self._update_preview()
        ).pack(side="left", padx=5)

        # Alpha
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Opacity:", width=100).pack(side="left")
        ctk.CTkSlider(
            frame,
            from_=0.1,
            to=1.0,
            variable=self.alpha_var,
            width=150,
            command=lambda v: self._update_preview()
        ).pack(side="left", padx=5)

        # Display options
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkCheckBox(
            frame,
            text="Visible",
            variable=self.visible_var,
            command=self._update_preview
        ).pack(side="left", padx=5)
        ctk.CTkCheckBox(
            frame,
            text="Show in Legend",
            variable=self.show_legend_var,
            command=self._update_preview
        ).pack(side="left", padx=5)

    def _create_processing_section(self, parent):
        """Create data processing section"""
        section = CollapsibleFrame(parent, "Data Processing", collapsed=True)
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # Missing data
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Missing Data:", width=100).pack(side="left")
        ctk.CTkComboBox(
            frame,
            variable=self.missing_method_var,
            values=["drop", "interpolate", "forward", "backward", "zero", "mean"],
            width=150,
            command=lambda e: self._update_preview()
        ).pack(side="left", padx=5)

        # Smoothing
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkCheckBox(
            frame,
            text="Enable Smoothing",
            variable=self.smoothing_var,
            command=self._update_preview
        ).pack(side="left", padx=5)

        ctk.CTkLabel(frame, text="Window:").pack(side="left", padx=5)
        ctk.CTkSlider(
            frame,
            from_=3,
            to=51,
            variable=self.smoothing_window_var,
            width=100,
            command=lambda v: self._update_preview()
        ).pack(side="left", padx=5)

    def _create_analysis_section(self, parent):
        """Create analysis options section"""
        section = CollapsibleFrame(parent, "Analysis Options", collapsed=True)
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # Trend line
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkCheckBox(
            frame,
            text="Show Trend Line",
            variable=self.show_trend_var,
            command=self._update_preview
        ).pack(side="left", padx=5)

        ctk.CTkComboBox(
            frame,
            variable=self.trend_type_var,
            values=["linear", "polynomial", "exponential", "moving_average"],
            width=120,
            command=lambda e: self._update_preview()
        ).pack(side="left", padx=5)

        # Statistics
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkCheckBox(
            frame,
            text="Show Statistics",
            variable=self.show_stats_var,
            command=self._update_preview
        ).pack(side="left", padx=5)

        # Peak detection
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkCheckBox(
            frame,
            text="Mark Peaks",
            variable=self.show_peaks_var,
            command=self._update_preview
        ).pack(side="left", padx=5)

        ctk.CTkLabel(frame, text="Prominence:").pack(side="left", padx=5)
        ctk.CTkSlider(
            frame,
            from_=0.01,
            to=0.5,
            variable=self.peak_prominence_var,
            width=100,
            command=lambda v: self._update_preview()
        ).pack(side="left", padx=5)

    def _create_legacy_section(self, parent):
        """Create legacy properties section"""
        section = CollapsibleFrame(parent, "Legacy Properties", collapsed=True)
        section.pack(fill="x", pady=5)
        content = section.get_content_frame()

        # Plot type
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Plot Type:", width=100).pack(side="left")
        ctk.CTkComboBox(
            frame,
            variable=self.plot_type_var,
            values=["line", "scatter", "both", "bar", "area", "step"],
            width=120,
            command=lambda e: self._update_preview()
        ).pack(side="left", padx=5)

        # Z-order
        frame = ctk.CTkFrame(content)
        frame.pack(fill="x", pady=5)
        ctk.CTkLabel(frame, text="Z-Order:", width=100).pack(side="left")
        ctk.CTkSlider(
            frame,
            from_=0,
            to=10,
            variable=self.z_order_var,
            width=150,
            command=lambda v: self._update_preview()
        ).pack(side="left", padx=5)

    def _create_preview_panel(self, parent):
        """Create preview panel"""
        # Title
        title = ctk.CTkLabel(parent, text="ðŸ“Š Live Preview", font=("", 14, "bold"))
        title.pack(pady=10)

        # Create matplotlib figure
        self.figure = Figure(figsize=(8, 6), dpi=80)
        self.ax = self.figure.add_subplot(111)

        # Create canvas
        self.canvas = FigureCanvasTkAgg(self.figure, master=parent)
        self.canvas.get_tk_widget().pack(fill="both", expand=True, padx=10, pady=10)

        # Info label
        self.info_label = ctk.CTkLabel(parent, text="", text_color="gray")
        self.info_label.pack(pady=5)

    def _create_buttons(self):
        """Create dialog buttons"""
        button_frame = ctk.CTkFrame(self.dialog)
        button_frame.pack(fill="x", pady=10)

        # Cancel button
        ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=self.dialog.destroy,
            width=100
        ).pack(side="right", padx=5)

        # Apply button
        apply_text = "Create" if self.mode == "create" else "Apply"
        ctk.CTkButton(
            button_frame,
            text=apply_text,
            command=self._apply,
            width=100
        ).pack(side="right", padx=5)

        # Reset button
        if self.mode == "edit":
            ctk.CTkButton(
                button_frame,
                text="Reset",
                command=self._load_series_config,
                width=100
            ).pack(side="right", padx=5)

    def _on_file_change(self, filename: str):
        """Handle file selection change"""
        # Check if x_combo and y_combo exist
        if not hasattr(self, 'x_combo') or not hasattr(self, 'y_combo'):
            return

        # Find file data
        file_data = None
        for f in self.files.values():
            if f.filename == filename:
                file_data = f
                break

        if not file_data:
            return

        # Update column lists
        columns = ["Index"] + list(file_data.data.columns)

        self.x_combo.configure(values=columns)
        self.y_combo.configure(values=columns[1:])  # Exclude Index for Y

        # Set defaults
        if not self.x_column_var.get():
            self.x_combo.set(columns[0])

        numeric_cols = file_data.get_numeric_columns()
        if numeric_cols and not self.y_column_var.get():
            self.y_combo.set(numeric_cols[0])

        # Update range sliders
        data_length = len(file_data.data)
        self.start_slider.configure(to=data_length - 1)
        self.end_slider.configure(to=data_length)
        self.end_var.set(min(1000, data_length))

        self._update_preview()

    def _update_range(self):
        """Update range labels and preview"""
        self.start_label.configure(text=str(self.start_var.get()))
        self.end_label.configure(text=str(self.end_var.get()))
        self._update_preview()

    def _choose_color(self):
        """Open color chooser"""
        color = colorchooser.askcolor(initialcolor=self.color_var.get())
        if color[1]:
            self.color_var.set(color[1])
            self.color_button.configure(fg_color=color[1])
            self._update_preview()

    def _update_preview(self):
        """Update the preview plot"""
        try:
            # Clear previous plot
            self.ax.clear()

            # Get file data
            filename = self.file_var.get()
            if not filename:
                return

            file_data = None
            for f in self.files.values():
                if f.filename == filename:
                    file_data = f
                    break

            if not file_data:
                return

            # Get data
            x_col = self.x_column_var.get()
            y_col = self.y_column_var.get()

            if not x_col or not y_col:
                return

            # Extract data
            start = self.start_var.get()
            end = self.end_var.get()
            df_slice = file_data.data.iloc[start:end]

            if x_col == "Index":
                x_data = np.arange(start, end)
            else:
                x_data = df_slice[x_col].values

            y_data = df_slice[y_col].values

            # Handle missing data
            method = self.missing_method_var.get()
            x_data, y_data = self._handle_missing_data(x_data, y_data, method)

            # Apply smoothing
            if self.smoothing_var.get():
                window = min(self.smoothing_window_var.get(), len(y_data))
                if window >= 3 and len(y_data) > window:
                    y_data = savgol_filter(y_data, window, min(3, window - 1))

            # Plot data based on plot type
            plot_type = self.plot_type_var.get()
            if plot_type == "line":
                self.ax.plot(
                    x_data, y_data,
                    color=self.color_var.get(),
                    linestyle=self.line_style_var.get(),
                    linewidth=self.line_width_var.get(),
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )
            elif plot_type == "scatter":
                self.ax.scatter(
                    x_data, y_data,
                    color=self.color_var.get(),
                    marker=self.marker_var.get() if self.marker_var.get() else "o",
                    s=self.marker_size_var.get() ** 2,
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )
            elif plot_type == "both":
                self.ax.plot(
                    x_data, y_data,
                    color=self.color_var.get(),
                    linestyle=self.line_style_var.get(),
                    linewidth=self.line_width_var.get(),
                    marker=self.marker_var.get() if self.marker_var.get() else "o",
                    markersize=self.marker_size_var.get(),
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )
            elif plot_type == "bar":
                self.ax.bar(
                    x_data, y_data,
                    color=self.color_var.get(),
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )
            elif plot_type == "area":
                self.ax.fill_between(
                    x_data, y_data,
                    color=self.color_var.get(),
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )
            elif plot_type == "step":
                self.ax.step(
                    x_data, y_data,
                    color=self.color_var.get(),
                    linestyle=self.line_style_var.get(),
                    linewidth=self.line_width_var.get(),
                    alpha=self.alpha_var.get(),
                    label=self.name_var.get() if self.show_legend_var.get() else ""
                )

            # Add trend line
            if self.show_trend_var.get():
                self._add_trend_line(x_data, y_data)

            # Add statistics
            if self.show_stats_var.get():
                self._add_statistics(y_data)

            # Mark peaks
            if self.show_peaks_var.get():
                self._mark_peaks(x_data, y_data)

            # Configure plot
            self.ax.set_xlabel(x_col)
            self.ax.set_ylabel(y_col)
            self.ax.set_title(f"Preview: {self.name_var.get()}")
            self.ax.grid(True, alpha=0.3)

            if self.show_legend_var.get():
                self.ax.legend()

            # Update info
            self.info_label.configure(
                text=f"Points: {len(y_data)} | "
                     f"Range: [{np.min(y_data):.3g}, {np.max(y_data):.3g}]"
            )

            # Refresh canvas
            self.canvas.draw()

        except Exception as e:
            self.info_label.configure(text=f"Error: {str(e)}", text_color="red")

    def _handle_missing_data(self, x_data, y_data, method: str):
        """Handle missing data"""
        mask = ~(pd.isna(x_data) | pd.isna(y_data))

        if method == "drop":
            return x_data[mask], y_data[mask]
        elif method == "interpolate":
            y_series = pd.Series(y_data).interpolate()
            return x_data, y_series.values
        elif method == "forward":
            y_series = pd.Series(y_data).ffill()
            return x_data, y_series.values
        elif method == "backward":
            y_series = pd.Series(y_data).bfill()
            return x_data, y_series.values
        elif method == "zero":
            return x_data, np.nan_to_num(y_data, 0)
        elif method == "mean":
            mean_val = np.nanmean(y_data)
            return x_data, np.nan_to_num(y_data, mean_val)

        return x_data[mask], y_data[mask]

    def _add_trend_line(self, x_data, y_data):
        """Add trend line to preview"""
        # Implementation similar to plot_manager
        pass

    def _add_statistics(self, y_data):
        """Add statistics to preview"""
        stats_text = f"Mean: {np.nanmean(y_data):.3g}\n"
        stats_text += f"Std: {np.nanstd(y_data):.3g}"

        self.ax.text(
            0.02, 0.98, stats_text,
            transform=self.ax.transAxes,
            fontsize=9,
            verticalalignment='top',
            bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5)
        )

    def _mark_peaks(self, x_data, y_data):
        """Mark peaks in preview"""
        prominence = self.peak_prominence_var.get() * (np.max(y_data) - np.min(y_data))
        peaks, _ = find_peaks(y_data, prominence=prominence)

        if len(peaks) > 0:
            self.ax.scatter(
                x_data[peaks], y_data[peaks],
                marker='^', s=100, color='red', zorder=5
            )

    def _load_series_config(self):
        """Load existing series configuration"""
        if not self.series:
            return

        # Basic settings
        self.name_var.set(self.series.name)

        # Find and set file
        file_data = None
        for f in self.files.values():
            if f.id == self.series.file_id:
                file_data = f
                self.file_var.set(f.filename)
                self._on_file_change(f.filename)
                break

        # Data columns
        self.x_column_var.set(self.series.x_column)
        self.y_column_var.set(self.series.y_column)
        self.start_var.set(self.series.start_index)
        self.end_var.set(self.series.end_index or len(file_data.data))

        # Visual properties
        self.color_var.set(self.series.color or "#3B82F6")
        self.color_button.configure(fg_color=self.color_var.get())
        self.line_style_var.set(self.series.line_style)
        self.line_width_var.set(self.series.line_width)
        self.marker_var.set(self.series.marker or "")
        self.marker_size_var.set(self.series.marker_size)
        self.alpha_var.set(self.series.alpha)

        # Options
        self.visible_var.set(self.series.visible)
        self.show_legend_var.set(self.series.show_in_legend)
        self.missing_method_var.set(self.series.missing_data_method)
        self.smoothing_var.set(self.series.smoothing_enabled)
        self.smoothing_window_var.set(self.series.smoothing_window)

        # Analysis
        self.show_trend_var.set(self.series.show_trendline)
        self.trend_type_var.set(self.series.trend_type)
        self.trend_order_var.set(self.series.trend_order)
        self.show_stats_var.set(self.series.show_statistics)
        self.show_peaks_var.set(self.series.show_peaks)
        self.peak_prominence_var.set(self.series.peak_prominence)

        # Legacy properties
        self.z_order_var.set(self.series.z_order)
        self.plot_type_var.set(self.series.plot_type)

        self._update_preview()

    def _apply(self):
        """Apply configuration and close dialog"""
        # Validate inputs
        if not self.name_var.get():
            messagebox.showerror("Error", "Please enter a series name")
            return

        if not self.file_var.get():
            messagebox.showerror("Error", "Please select a file")
            return

        if not self.y_column_var.get():
            messagebox.showerror("Error", "Please select Y column")
            return

        # Find file ID
        file_id = None
        for f in self.files.values():
            if f.filename == self.file_var.get():
                file_id = f.id
                break

        if not file_id:
            messagebox.showerror("Error", "File not found")
            return

        # Create or update series
        if self.mode == "create":
            series = SeriesConfig(
                name=self.name_var.get(),
                file_id=file_id,
                x_column=self.x_column_var.get(),
                y_column=self.y_column_var.get()
            )
        else:
            series = self.series
            series.name = self.name_var.get()
            series.file_id = file_id
            series.x_column = self.x_column_var.get()
            series.y_column = self.y_column_var.get()

        # Update all properties
        series.start_index = self.start_var.get()
        series.end_index = self.end_var.get()
        series.color = self.color_var.get()
        series.line_style = self.line_style_var.get()
        series.line_width = self.line_width_var.get()
        series.marker = self.marker_var.get() if self.marker_var.get() else None
        series.marker_size = self.marker_size_var.get()
        series.alpha = self.alpha_var.get()
        series.visible = self.visible_var.get()
        series.show_in_legend = self.show_legend_var.get()
        series.legend_label = self.name_var.get()
        series.missing_data_method = self.missing_method_var.get()
        series.smoothing_enabled = self.smoothing_var.get()
        series.smoothing_window = self.smoothing_window_var.get()
        series.show_trendline = self.show_trend_var.get()
        series.trend_type = self.trend_type_var.get()
        series.trend_order = self.trend_order_var.get()
        series.show_statistics = self.show_stats_var.get()
        series.show_peaks = self.show_peaks_var.get()
        series.peak_prominence = self.peak_prominence_var.get()
        series.z_order = self.z_order_var.get()
        series.plot_type = self.plot_type_var.get()

        # Set result and close
        self.result = series
        self.dialog.destroy()

    def _center_dialog(self):
        """Center dialog on screen"""
        self.dialog.update_idletasks()
        x = (self.dialog.winfo_screenwidth() // 2) - (self.dialog.winfo_width() // 2)
        y = (self.dialog.winfo_screenheight() // 2) - (self.dialog.winfo_height() // 2)
        self.dialog.geometry(f"+{x}+{y}")


class StatisticalAnalysisDialog:
    """Dialog for data analysis - Enhanced with Legacy Features"""

    def __init__(
            self,
            parent,
            series_configs: Dict[str, SeriesConfig],
            loaded_files: Dict[str, FileData],
            statistical_analyzer,
            vacuum_analyzer
    ):
        self.parent = parent
        self.series_configs = series_configs
        self.loaded_files = loaded_files
        self.statistical_analyzer = statistical_analyzer
        self.vacuum_analyzer = vacuum_analyzer
        self.vacuum_results = {}

        # Create dialog
        self.dialog = ctk.CTkToplevel(parent)
        self.dialog.title("Data Analysis Tools")
        self.dialog.geometry("1000x700")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Initialize theme manager
        from ui.theme_manager import theme_manager
        self.theme_manager = theme_manager

        # Create notebook for different analysis types
        self.notebook = ctk.CTkTabview(self.dialog)
        self.notebook.pack(fill="both", expand=True, padx=10, pady=10)

        # Add analysis tabs
        self._create_statistical_tab()
        self._create_vacuum_tab()
        self._create_comparison_tab()

        # Buttons
        button_frame = ctk.CTkFrame(self.dialog)
        button_frame.pack(fill="x", pady=10)

        ctk.CTkButton(
            button_frame,
            text="Export Results",
            command=self._export_results,
            width=120
        ).pack(side="right", padx=5)

        ctk.CTkButton(
            button_frame,
            text="Close",
            command=self.dialog.destroy,
            width=100
        ).pack(side="right", padx=5)

    def _create_statistical_tab(self):
        """Create statistical analysis tab"""
        tab = self.notebook.add("ðŸ“Š Statistical Analysis")

        # Series selection
        select_frame = ctk.CTkFrame(tab)
        select_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(select_frame, text="Select Series:").pack(side="left", padx=5)

        self.stat_series_var = tk.StringVar()
        series_names = [s.name for s in self.series_configs.values()]
        ctk.CTkComboBox(
            select_frame,
            variable=self.stat_series_var,
            values=series_names,
            width=200
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            select_frame,
            text="Analyze",
            command=self._run_statistical_analysis,
            width=100
        ).pack(side="left", padx=10)

        # Results display
        self.stat_results = ctk.CTkTextbox(tab, wrap="word", height=400)
        self.stat_results.pack(fill="both", expand=True, padx=10, pady=10)

    def _create_vacuum_tab(self):
        """Create vacuum analysis tab with legacy features"""
        tab = self.notebook.add("ðŸŽ¯ Vacuum Analysis")

        # Create notebook for vacuum sub-tabs
        vacuum_notebook = ctk.CTkTabview(tab)
        vacuum_notebook.pack(fill="both", expand=True, padx=10, pady=10)

        # Add vacuum sub-tabs
        self._create_base_pressure_tab(vacuum_notebook)
        self._create_spike_detection_tab(vacuum_notebook)
        self._create_leak_detection_tab(vacuum_notebook)
        self._create_pumpdown_tab(vacuum_notebook)

    def _create_base_pressure_tab(self, notebook):
        """Create base pressure analysis tab"""
        tab = notebook.add("Base Pressure")

        # Series selection
        frame = ctk.CTkFrame(tab)
        frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(frame, text="Series:").pack(side="left", padx=5)
        self.base_series_var = tk.StringVar()
        series_names = [s.name for s in self.series_configs.values()]
        ctk.CTkComboBox(
            frame,
            variable=self.base_series_var,
            values=series_names,
            width=200
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            frame,
            text="Analyze",
            command=self._run_base_pressure_analysis,
            width=100
        ).pack(side="left", padx=10)

        # Parameters
        param_frame = ctk.CTkFrame(tab)
        param_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(param_frame, text="Window Size (min):").pack(side="left", padx=5)
        self.window_size_var = tk.IntVar(value=10)
        ctk.CTkSlider(
            param_frame,
            from_=1,
            to=60,
            variable=self.window_size_var,
            width=150
        ).pack(side="left", padx=5)
        ctk.CTkLabel(param_frame, textvariable=self.window_size_var).pack(side="left", padx=5)

        # Results
        results_frame = ctk.CTkFrame(tab)
        results_frame.pack(fill="both", expand=True, padx=10, pady=10)

        self.base_text = tk.Text(results_frame, wrap="word")
        scrollbar = ttk.Scrollbar(results_frame, command=self.base_text.yview)
        self.base_text.config(yscrollcommand=scrollbar.set)

        scrollbar.pack(side="right", fill="y")
        self.base_text.pack(side="left", fill="both", expand=True)

    def _create_spike_detection_tab(self, notebook):
        """Create spike detection tab"""
        tab = notebook.add("Spike Detection")

        # Series selection
        frame = ctk.CTkFrame(tab)
        frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(frame, text="Series:").pack(side="left", padx=5)
        self.spike_series_var = tk.StringVar()
        series_names = [s.name for s in self.series_configs.values()]
        ctk.CTkComboBox(
            frame,
            variable=self.spike_series_var,
            values=series_names,
            width=200
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            frame,
            text="Detect",
            command=self._detect_spikes,
            width=100
        ).pack(side="left", padx=10)

        # Parameters
        param_frame = ctk.CTkFrame(tab)
        param_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(param_frame, text="Threshold (Ïƒ):").pack(side="left", padx=5)
        self.spike_threshold_var = tk.DoubleVar(value=3.0)
        ctk.CTkSlider(
            param_frame,
            from_=1.0,
            to=10.0,
            variable=self.spike_threshold_var,
            width=150
        ).pack(side="left", padx=5)
        ctk.CTkLabel(param_frame, textvariable=self.spike_threshold_var).pack(side="left", padx=5)

        # Results
        results_frame = ctk.CTkFrame(tab)
        results_frame.pack(fill="both", expand=True, padx=10, pady=10)

        columns = ("#", "Start Time", "End Time", "Duration", "Max Pressure", "Severity")
        self.spikes_tree = ttk.Treeview(results_frame, columns=columns, show="headings", height=10)

        for col in columns:
            self.spikes_tree.heading(col, text=col)
            self.spikes_tree.column(col, width=100)

        scrollbar = ttk.Scrollbar(results_frame, orient="vertical", command=self.spikes_tree.yview)
        self.spikes_tree.configure(yscrollcommand=scrollbar.set)

        scrollbar.pack(side="right", fill="y")
        self.spikes_tree.pack(side="left", fill="both", expand=True)

    def _create_leak_detection_tab(self, notebook):
        """Create leak detection tab"""
        tab = notebook.add("Leak Detection")

        # Series selection
        frame = ctk.CTkFrame(tab)
        frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(frame, text="Series:").pack(side="left", padx=5)
        self.leak_series_var = tk.StringVar()
        series_names = [s.name for s in self.series_configs.values()]
        ctk.CTkComboBox(
            frame,
            variable=self.leak_series_var,
            values=series_names,
            width=200
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            frame,
            text="Detect",
            command=self._detect_leaks,
            width=100
        ).pack(side="left", padx=10)

        # Results
        results_frame = ctk.CTkFrame(tab)
        results_frame.pack(fill="both", expand=True, padx=10, pady=10)

        self.leak_text = tk.Text(results_frame, wrap="word")
        scrollbar = ttk.Scrollbar(results_frame, command=self.leak_text.yview)
        self.leak_text.config(yscrollcommand=scrollbar.set)

        scrollbar.pack(side="right", fill="y")
        self.leak_text.pack(side="left", fill="both", expand=True)

    def _create_pumpdown_tab(self, notebook):
        """Create pump-down analysis tab"""
        tab = notebook.add("Pump-down")

        # Series selection
        frame = ctk.CTkFrame(tab)
        frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkLabel(frame, text="Series:").pack(side="left", padx=5)
        self.pump_series_var = tk.StringVar()
        series_names = [s.name for s in self.series_configs.values()]
        ctk.CTkComboBox(
            frame,
            variable=self.pump_series_var,
            values=series_names,
            width=200
        ).pack(side="left", padx=5)

        ctk.CTkButton(
            frame,
            text="Analyze",
            command=self._analyze_pumpdown,
            width=100
        ).pack(side="left", padx=10)

        # Results
        results_frame = ctk.CTkFrame(tab)
        results_frame.pack(fill="both", expand=True, padx=10, pady=10)

        self.pump_text = tk.Text(results_frame, wrap="word")
        scrollbar = ttk.Scrollbar(results_frame, command=self.pump_text.yview)
        self.pump_text.config(yscrollcommand=scrollbar.set)

        scrollbar.pack(side="right", fill="y")
        self.pump_text.pack(side="left", fill="both", expand=True)

    def _create_comparison_tab(self):
        """Create enhanced comparison tab with smart screen-aware two-column layout"""
        tab = self.notebook.add("ðŸ“Š Comparison")
        
        # Get screen dimensions for intelligent sizing
        screen_width = self.dialog.winfo_screenwidth()
        screen_height = self.dialog.winfo_screenheight()
        
        # Calculate optimal dialog size based on screen (85% of screen, with limits)
        dialog_width = min(1600, max(1200, int(screen_width * 0.85)))
        dialog_height = min(1000, max(800, int(screen_height * 0.85)))
        
        # Resize dialog to be screen-aware
        self.dialog.geometry(f"{dialog_width}x{dialog_height}")
        
        # Main container with intelligent two-column layout
        main_container = ctk.CTkFrame(tab, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Create left and right frames using pack instead of grid to avoid conflict
        left_frame_wrapper = ctk.CTkFrame(main_container, fg_color="transparent")
        left_frame_wrapper.pack(side="left", fill="both", expand=True, padx=(0, 5))
        
        right_frame_wrapper = ctk.CTkFrame(main_container, fg_color="transparent")
        right_frame_wrapper.pack(side="right", fill="both", expand=True, padx=(5, 0))
        
        # === LEFT COLUMN: Controls and Configuration ===
        left_panel = ctk.CTkScrollableFrame(
            left_frame_wrapper,
            corner_radius=10,
            label_text="ðŸŽ›ï¸ Comparison Configuration"
        )
        left_panel.pack(fill="both", expand=True)
        
        # Header with description
        desc_label = ctk.CTkLabel(
            left_panel,
            text="ðŸ§  Intelligent comparison with series name recognition",
            font=ctk.CTkFont(size=11),
            text_color=("gray60", "gray40"),
            wraplength=int(dialog_width * 0.35)
        )
        desc_label.pack(anchor="w", pady=(0, 15))
        
        # === Series Selection Section ===
        selection_frame = ctk.CTkFrame(left_panel, corner_radius=8)
        selection_frame.pack(fill="x", pady=(0, 15))
        
        ctk.CTkLabel(
            selection_frame,
            text="ðŸ“ˆ Series Selection",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(anchor="w", padx=15, pady=(15, 5))
        
        # Get series names (not IDs) for intelligent display
        series_names = [config.name for config in self.series_configs.values() if config.name]
        
        # Primary series
        primary_frame = ctk.CTkFrame(selection_frame, corner_radius=6)
        primary_frame.pack(fill="x", padx=15, pady=(0, 10))
        
        ctk.CTkLabel(
            primary_frame,
            text="ðŸ”µ Primary Series",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(8, 2))
        
        self.comp_primary_var = tk.StringVar()
        self.comp_primary_combo = ctk.CTkComboBox(
            primary_frame,
            variable=self.comp_primary_var,
            values=series_names,
            width=int(dialog_width * 0.32),
            height=30,
            corner_radius=6,
            command=self._on_primary_series_change
        )
        self.comp_primary_combo.pack(padx=10, pady=(0, 5))
        
        # Primary series info preview
        self.primary_info_label = ctk.CTkLabel(
            primary_frame,
            text="Select a series to see intelligent preview",
            font=ctk.CTkFont(size=9),
            text_color=("gray60", "gray40"),
            wraplength=int(dialog_width * 0.32)
        )
        self.primary_info_label.pack(anchor="w", padx=10, pady=(0, 8))
        
        # Secondary series
        secondary_frame = ctk.CTkFrame(selection_frame, corner_radius=6)
        secondary_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        ctk.CTkLabel(
            secondary_frame,
            text="ï¿½ Secondary Series",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(8, 2))
        
        self.comp_secondary_var = tk.StringVar()
        self.comp_secondary_combo = ctk.CTkComboBox(
            secondary_frame,
            variable=self.comp_secondary_var,
            values=series_names,
            width=int(dialog_width * 0.32),
            height=30,
            corner_radius=6,
            command=self._on_secondary_series_change
        )
        self.comp_secondary_combo.pack(padx=10, pady=(0, 5))
        
        # Secondary series info preview
        self.secondary_info_label = ctk.CTkLabel(
            secondary_frame,
            text="Select a series to see intelligent preview",
            font=ctk.CTkFont(size=9),
            text_color=("gray60", "gray40"),
            wraplength=int(dialog_width * 0.32)
        )
        self.secondary_info_label.pack(anchor="w", padx=10, pady=(0, 8))
        
        # === Analysis Configuration Section ===
        config_frame = ctk.CTkFrame(left_panel, corner_radius=8)
        config_frame.pack(fill="x", pady=(0, 15))
        
        ctk.CTkLabel(
            config_frame,
            text="âš™ï¸ Analysis Configuration",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(anchor="w", padx=15, pady=(15, 5))
        
        # Comparison type selection
        comp_type_frame = ctk.CTkFrame(config_frame, corner_radius=6)
        comp_type_frame.pack(fill="x", padx=15, pady=(0, 10))
        
        ctk.CTkLabel(
            comp_type_frame,
            text="ðŸ“Š Comparison Type",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(8, 2))
        
        self.comp_type_var = tk.StringVar(value="Smart Overlay")
        comp_type_values = [
            "Smart Overlay", "Side-by-Side", "Difference Analysis", 
            "Correlation Plot", "Statistical Summary", "Performance Comparison"
        ]
        self.comp_type_combo = ctk.CTkComboBox(
            comp_type_frame,
            variable=self.comp_type_var,
            values=comp_type_values,
            width=int(dialog_width * 0.32),
            height=30,
            corner_radius=6,
            command=self._on_comparison_type_change
        )
        self.comp_type_combo.pack(padx=10, pady=(0, 5))
        
        # Description for comparison type
        self.comp_type_desc = ctk.CTkLabel(
            comp_type_frame,
            text="Intelligent overlay with auto-scaling and optimal color selection",
            font=ctk.CTkFont(size=9),
            text_color=("gray60", "gray40"),
            wraplength=int(dialog_width * 0.32)
        )
        self.comp_type_desc.pack(anchor="w", padx=10, pady=(0, 8))
        
        # Time alignment options
        align_frame = ctk.CTkFrame(config_frame, corner_radius=6)
        align_frame.pack(fill="x", padx=15, pady=(0, 10))
        
        ctk.CTkLabel(
            align_frame,
            text="â±ï¸ Time Alignment",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(8, 2))
        
        self.time_align_var = tk.StringVar(value="Auto-Detect")
        align_values = [
            "Auto-Detect", "None", "Start Times", "Peak Alignment", 
            "Cross-Correlation", "Custom Offset"
        ]
        self.time_align_combo = ctk.CTkComboBox(
            align_frame,
            variable=self.time_align_var,
            values=align_values,
            width=int(dialog_width * 0.32),
            height=30,
            corner_radius=6,
            command=self._on_alignment_change
        )
        self.time_align_combo.pack(padx=10, pady=(0, 5))
        
        # Alignment description
        self.align_desc = ctk.CTkLabel(
            align_frame,
            text="Smart alignment detection based on data characteristics",
            font=ctk.CTkFont(size=9),
            text_color=("gray60", "gray40"),
            wraplength=int(dialog_width * 0.32)
        )
        self.align_desc.pack(anchor="w", padx=10, pady=(0, 8))
        
        # Advanced options
        advanced_frame = ctk.CTkFrame(config_frame, corner_radius=6)
        advanced_frame.pack(fill="x", padx=15, pady=(0, 15))
        
        ctk.CTkLabel(
            advanced_frame,
            text="ðŸ”¬ Advanced Options",
            font=ctk.CTkFont(weight="bold", size=12)
        ).pack(anchor="w", padx=10, pady=(8, 5))
        
        # Confidence level
        confidence_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        confidence_frame.pack(fill="x", padx=10, pady=(0, 5))
        
        confidence_label_frame = ctk.CTkFrame(confidence_frame, fg_color="transparent")
        confidence_label_frame.pack(fill="x")
        
        ctk.CTkLabel(
            confidence_label_frame,
            text="Confidence Level:",
            font=ctk.CTkFont(size=11)
        ).pack(side="left")
        
        self.confidence_label = ctk.CTkLabel(
            confidence_label_frame,
            text="95%",
            font=ctk.CTkFont(size=11, weight="bold"),
            text_color=("#1E40AF", "#3B82F6")
        )
        self.confidence_label.pack(side="right")
        
        self.confidence_var = tk.DoubleVar(value=0.95)
        confidence_slider = ctk.CTkSlider(
            confidence_frame,
            from_=0.8,
            to=0.99,
            variable=self.confidence_var,
            width=int(dialog_width * 0.28),
            height=20,
            number_of_steps=19
        )
        confidence_slider.pack(pady=(5, 5))
        
        # Smart toggles
        toggles_frame = ctk.CTkFrame(advanced_frame, fg_color="transparent")
        toggles_frame.pack(fill="x", padx=10, pady=(0, 8))
        
        self.auto_analysis_var = tk.BooleanVar(value=True)
        ctk.CTkCheckBox(
            toggles_frame,
            text="ðŸ¤– Auto-update analysis",
            variable=self.auto_analysis_var,
            font=ctk.CTkFont(size=11)
        ).pack(anchor="w", pady=2)
        
        # === Action Buttons ===
        button_frame = ctk.CTkFrame(left_panel, corner_radius=8)
        button_frame.pack(fill="x", pady=(0, 10))
        
        # Main action buttons
        main_buttons = ctk.CTkFrame(button_frame, fg_color="transparent")
        main_buttons.pack(fill="x", padx=15, pady=15)
        
        self.run_button = ctk.CTkButton(
            main_buttons,
            text="ðŸš€ Run Analysis",
            command=self.run_comparison_analysis,
            width=int(dialog_width * 0.32),
            height=40,
            corner_radius=8,
            font=ctk.CTkFont(size=12, weight="bold"),
            fg_color=("#1E40AF", "#3B82F6"),
            hover_color=("#1E3A8A", "#2563EB")
        )
        self.run_button.pack(fill="x", pady=(0, 8))
        
        # Quick action buttons row
        quick_actions = ctk.CTkFrame(main_buttons, fg_color="transparent")
        quick_actions.pack(fill="x")
        
        ctk.CTkButton(
            quick_actions,
            text="âš¡ Quick",
            command=self._quick_compare,
            width=int(dialog_width * 0.09),
            height=32,
            corner_radius=6,
            font=ctk.CTkFont(size=10)
        ).pack(side="left", padx=(0, 3), fill="x", expand=True)
        
        ctk.CTkButton(
            quick_actions,
            text="ðŸ“‹ Copy",
            command=self._copy_results,
            width=int(dialog_width * 0.09),
            height=32,
            corner_radius=6,
            font=ctk.CTkFont(size=10)
        ).pack(side="left", padx=2, fill="x", expand=True)
        
        ctk.CTkButton(
            quick_actions,
            text="ðŸ”„ Reset",
            command=self._reset_comparison,
            width=int(dialog_width * 0.09),
            height=32,
            corner_radius=6,
            font=ctk.CTkFont(size=10)
        ).pack(side="left", padx=(3, 0), fill="x", expand=True)
        
        # === RIGHT COLUMN: Results and Visualization ===
        right_panel = ctk.CTkFrame(
            right_frame_wrapper,
            corner_radius=10
        )
        right_panel.pack(fill="both", expand=True)
        
        # Results header with status
        results_header = ctk.CTkFrame(right_panel, height=50, corner_radius=8)
        results_header.pack(fill="x", padx=15, pady=(15, 10))
        results_header.pack_propagate(False)
        
        # Header content frame to manage left and right elements
        header_content = ctk.CTkFrame(results_header, fg_color="transparent")
        header_content.pack(fill="both", expand=True, padx=15, pady=12)
        
        ctk.CTkLabel(
            header_content,
            text="ðŸ“Š Analysis Results & Visualization",
            font=ctk.CTkFont(size=16, weight="bold")
        ).pack(side="left")
        
        # Dynamic status indicator
        self.status_label = ctk.CTkLabel(
            header_content,
            text="ðŸŸ¡ Ready for analysis",
            font=ctk.CTkFont(size=10),
            text_color=("gray60", "gray40")
        )
        self.status_label.pack(side="right")
        
        # Tabbed results with intelligent height based on screen
        results_height = max(500, dialog_height - 250)
        
        self.results_tabview = ctk.CTkTabview(
            right_panel,
            height=results_height,
            corner_radius=8
        )
        self.results_tabview.pack(fill="both", expand=True, padx=15, pady=(0, 15))
        
        # === Visualization Tab ===
        viz_tab = self.results_tabview.add("ðŸ“ˆ Visualization")
        
        # Plot container with scrolling for large plots
        self.comparison_plot_frame = ctk.CTkScrollableFrame(
            viz_tab,
            corner_radius=6
        )
        self.comparison_plot_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Initial message
        initial_viz_msg = ctk.CTkLabel(
            self.comparison_plot_frame,
            text="ðŸŽ¯ Select two series and run analysis\nto see intelligent visualization",
            font=ctk.CTkFont(size=12),
            text_color=("gray60", "gray40"),
            justify="center"
        )
        initial_viz_msg.pack(expand=True, pady=50)
        
        # === Statistics Tab ===
        stats_tab = self.results_tabview.add("ðŸ“Š Statistics")
        
        self.comparison_results = ctk.CTkTextbox(
            stats_tab,
            corner_radius=6,
            font=ctk.CTkFont(family="Consolas", size=11),
            wrap="word"
        )
        self.comparison_results.pack(fill="both", expand=True, padx=10, pady=10)
        
        # === AI Insights Tab ===
        insights_tab = self.results_tabview.add("ðŸ§  AI Insights")
        
        self.insights_text = ctk.CTkTextbox(
            insights_tab,
            corner_radius=6,
            font=ctk.CTkFont(size=11),
            wrap="word"
        )
        self.insights_text.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Configure event handlers for intelligent behavior
        confidence_slider.configure(command=self._update_confidence_label)

