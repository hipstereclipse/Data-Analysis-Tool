    def _create_vacuum_tab(self):
            variable=self.confidence_var,
            width=80
        )
        confidence_slider.pack(side="right")
        
        self.confidence_label = ctk.CTkLabel(
            confidence_frame,
            text="95%",
            font=ctk.CTkFont(size=10)
        )
        self.confidence_label.pack(side="right", padx=(5, 5))
        
        # Auto-analysis toggle
        self.auto_analysis_var = tk.BooleanVar(value=True)
        auto_check = ctk.CTkCheckBox(
            advanced_frame,
            text="Auto-update on selection change",
            variable=self.auto_analysis_var,
            font=ctk.CTkFont(size=10)
        )
        auto_check.pack(anchor="w", padx=10, pady=(0, 10))
        
        # (OLD CODE SECTION REMOVED - Replaced with new two-column layout above)
        button_frame.pack(fill="x", padx=10, pady=(0, 15))
        
        # Left side - main actions
        left_buttons = ctk.CTkFrame(button_frame, fg_color="transparent")
        left_buttons.pack(side="left")
        
        self.run_button = ctk.CTkButton(
            left_buttons,
            text="🚀 Run Smart Analysis",
            command=self.run_comparison_analysis,
            width=160,
            height=40,
            corner_radius=10,
            font=ctk.CTkFont(size=14, weight="bold"),
            fg_color=("#3B82F6", "#1E40AF"),
            hover_color=("#2563EB", "#1E3A8A")
        )
        self.run_button.pack(side="left", padx=(0, 10))
        
        self.quick_compare_button = ctk.CTkButton(
            left_buttons,
            text="⚡ Quick Compare",
            command=self._quick_compare,
            width=130,
            height=40,
            corner_radius=10,
            font=ctk.CTkFont(size=12, weight="bold")
        )
        self.quick_compare_button.pack(side="left", padx=(0, 10))
        
        # Right side - utility actions
        right_buttons = ctk.CTkFrame(button_frame, fg_color="transparent")
        right_buttons.pack(side="right")
        
        ctk.CTkButton(
            right_buttons,
            text="📋 Copy Results",
            command=self._copy_results,
            width=110,
            height=35,
            corner_radius=8
        ).pack(side="left", padx=(0, 5))
        
        ctk.CTkButton(
            right_buttons,
            text="💾 Export",
            command=self.export_comparison_results,
            width=90,
            height=35,
            corner_radius=8
        ).pack(side="left", padx=(0, 5))
        
        ctk.CTkButton(
            right_buttons,
            text="🔄 Reset",
            command=self._reset_comparison,
            width=80,
            height=35,
            corner_radius=8,
            fg_color=("gray70", "gray30"),
            hover_color=("gray60", "gray40")
        ).pack(side="left")
        
        # (OLD RESULTS SECTION REMOVED - Replaced with new right-column layout above)
        # (Old results container section removed - replaced with new right-column layout above)
        self.results_tabview.pack(fill="both", expand=True, padx=15, pady=15)
        
        # Visualization tab
        viz_tab = self.results_tabview.add("📈 Visualization")
        self.comparison_plot_frame = ctk.CTkFrame(viz_tab, corner_radius=8)
        self.comparison_plot_frame.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Statistics tab
        stats_tab = self.results_tabview.add("📊 Statistics")
        
        # Create statistics display with better formatting
        stats_container = ctk.CTkFrame(stats_tab, fg_color="transparent")
        stats_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        # Split statistics into sections
        stats_left = ctk.CTkFrame(stats_container)
        stats_left.pack(side="left", fill="both", expand=True, padx=(0, 5))
        
        ctk.CTkLabel(
            stats_left,
            text="Statistical Summary",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(anchor="w", padx=10, pady=(10, 5))
        
        self.comparison_results = ctk.CTkTextbox(
            stats_left,
            corner_radius=8,
            font=ctk.CTkFont(family="Consolas", size=11)
        )
        self.comparison_results.pack(fill="both", expand=True, padx=10, pady=(0, 10))
        
        # Insights tab
        insights_tab = self.results_tabview.add("🧠 AI Insights")
        
        insights_container = ctk.CTkFrame(insights_tab, fg_color="transparent")
        insights_container.pack(fill="both", expand=True, padx=10, pady=10)
        
        ctk.CTkLabel(
            insights_container,
            text="Intelligent Analysis Insights",
            font=ctk.CTkFont(size=14, weight="bold")
        ).pack(anchor="w", padx=10, pady=(10, 5))
        
        self.insights_text = ctk.CTkTextbox(
            insights_container,
            corner_radius=8,
            font=ctk.CTkFont(size=12)
        )
        self.insights_text.pack(fill="both", expand=True, padx=10, pady=(0, 10))
        
        # Update confidence label when slider changes
        confidence_slider.configure(command=self._update_confidence_label)
        
        # Initialize with smart defaults
        self.root.after(100, self._initialize_smart_defaults)

    def _initialize_smart_defaults(self):
        """Initialize smart defaults for the comparison interface"""
        # Set up auto-completion and smart suggestions
        if hasattr(self, 'series_configs') and self.series_configs:
            series_names = [config.name for config in self.series_configs.values() if config.name]
            
            if len(series_names) >= 2:
                # Auto-select first two series for quick start
                self.comp_primary_var.set(series_names[0])
                self.comp_secondary_var.set(series_names[1])
                self._on_primary_series_change(series_names[0])
                self._on_secondary_series_change(series_names[1])
    
    def _on_primary_series_change(self, selected_name):
        """Handle primary series selection change"""
        if not selected_name:
            return
            
        # Find the series config by name
        series_config = None
        for config in self.series_configs.values():
            if config.name == selected_name:
                series_config = config
                break
        
        if series_config:
            # Get file data for preview
            file_data = self.loaded_files.get(series_config.file_id)
            if file_data:
                x_data, y_data = series_config.get_data(file_data)
                
                # Generate smart info display
                info_text = f"📈 {len(y_data):,} points | "
                info_text += f"Range: {y_data.min():.2e} to {y_data.max():.2e} | "
                info_text += f"File: {file_data.filename}"
                
                self.primary_info_label.configure(text=info_text)
                
                # Update secondary series options (exclude selected primary)
                other_series = [config.name for config in self.series_configs.values() 
                              if config.name and config.name != selected_name]
                self.comp_secondary_combo.configure(values=other_series)
                
                # Auto-run analysis if enabled
                if hasattr(self, 'auto_analysis_var') and self.auto_analysis_var.get():
                    if self.comp_secondary_var.get() and self.comp_secondary_var.get() != selected_name:
                        self._quick_compare()
    
    def _on_secondary_series_change(self, selected_name):
        """Handle secondary series selection change"""
        if not selected_name:
            return
            
        # Find the series config by name
        series_config = None
        for config in self.series_configs.values():
            if config.name == selected_name:
                series_config = config
                break
        
        if series_config:
            # Get file data for preview
            file_data = self.loaded_files.get(series_config.file_id)
            if file_data:
                x_data, y_data = series_config.get_data(file_data)
                
                # Generate smart info display
                info_text = f"📈 {len(y_data):,} points | "
                info_text += f"Range: {y_data.min():.2e} to {y_data.max():.2e} | "
                info_text += f"File: {file_data.filename}"
                
                self.secondary_info_label.configure(text=info_text)
                
                # Update primary series options (exclude selected secondary)
                other_series = [config.name for config in self.series_configs.values() 
                              if config.name and config.name != selected_name]
                self.comp_primary_combo.configure(values=other_series)
                
                # Auto-run analysis if enabled
                if hasattr(self, 'auto_analysis_var') and self.auto_analysis_var.get():
                    if self.comp_primary_var.get() and self.comp_primary_var.get() != selected_name:
                        self._quick_compare()
    
    def _on_comparison_type_change(self, selected_type):
        """Update description when comparison type changes"""
        descriptions = {
            "Smart Overlay": "Intelligent overlay with auto-scaling and optimal color selection",
            "Side-by-Side": "Independent plots for detailed individual analysis",
            "Difference Analysis": "Point-by-point difference with statistical significance",
            "Correlation Plot": "Scatter plot with correlation metrics and trend analysis",
            "Statistical Summary": "Comprehensive statistical comparison and tests",
            "Performance Comparison": "Vacuum-specific performance metrics and ratings"
        }
        
        desc = descriptions.get(selected_type, "Advanced comparison analysis")
        self.comp_type_desc.configure(text=desc)
        
        # Auto-suggest best alignment for this comparison type
        if selected_type in ["Difference Analysis", "Correlation Plot"]:
            self.time_align_var.set("Auto-Detect")
        elif selected_type == "Performance Comparison":
            self.time_align_var.set("Start Times")
    
    def _on_alignment_change(self, selected_alignment):
        """Update description when alignment method changes"""
        descriptions = {
            "Auto-Detect": "Smart alignment detection based on data characteristics",
            "None": "No alignment - use original time bases",
            "Start Times": "Align series start times to zero",
            "Peak Alignment": "Align based on maximum values",
            "Cross-Correlation": "Optimal lag detection using correlation",
            "Custom Offset": "Manual time offset specification"
        }
        
        desc = descriptions.get(selected_alignment, "Time series alignment")
        self.align_desc.configure(text=desc)
    
    def _update_confidence_label(self, value):
        """Update confidence level label"""
        self.confidence_label.configure(text=f"{int(float(value) * 100)}%")
    
    def _quick_compare(self):
        """Run a quick comparison with smart defaults"""
        if not self.comp_primary_var.get() or not self.comp_secondary_var.get():
            return
        
        # Save current settings
        original_type = self.comp_type_var.get()
        
        # Set to smart overlay for quick comparison
        self.comp_type_var.set("Smart Overlay")
        
        # Run the analysis
        self.run_comparison_analysis()
        
        # Restore original type
        self.comp_type_var.set(original_type)
    
    def _copy_results(self):
        """Copy results to clipboard"""
        try:
            results_text = self.comparison_results.get("1.0", "end-1c")
            self.comparison_results.clipboard_clear()
            self.comparison_results.clipboard_append(results_text)
            
            # Show temporary feedback
            original_text = self.comparison_results.get("1.0", "1.0 lineend")
            self.comparison_results.insert("1.0", "📋 Results copied to clipboard!\n\n")
            self.comparison_results.after(2000, lambda: self._remove_copy_notification())
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to copy results: {str(e)}")
    
    def _remove_copy_notification(self):
        """Remove the copy notification"""
        try:
            content = self.comparison_results.get("1.0", "end-1c")
            if content.startswith("📋 Results copied"):
                # Remove the first two lines (notification + empty line)
                lines = content.split('\n')
                new_content = '\n'.join(lines[2:])
                self.comparison_results.delete("1.0", "end")
                self.comparison_results.insert("1.0", new_content)
        except:
            pass
    
    def _reset_comparison(self):
        """Reset comparison interface to defaults"""
        self.comp_primary_var.set("")
        self.comp_secondary_var.set("")
        self.comp_type_var.set("Smart Overlay")
        self.time_align_var.set("Auto-Detect")
        self.confidence_var.set(0.95)
        self.auto_analysis_var.set(True)
        
        # Clear results
        self.comparison_results.delete("1.0", "end")
        self.insights_text.delete("1.0", "end")
        
        # Clear plot
        for widget in self.comparison_plot_frame.winfo_children():
            widget.destroy()
        
        # Reset info labels
        self.primary_info_label.configure(text="Select a series to see details")
        self.secondary_info_label.configure(text="Select a series to see details")
        
        # Restore series options
        series_names = [config.name for config in self.series_configs.values() if config.name]
        self.comp_primary_combo.configure(values=series_names)
        self.comp_secondary_combo.configure(values=series_names)

    def run_comparison_analysis(self):
        """Run intelligent comparison analysis between two series"""
        primary_name = self.comp_primary_var.get()
        secondary_name = self.comp_secondary_var.get()
        
        if not primary_name or not secondary_name:
            messagebox.showwarning("⚠️ Selection Required", 
                                 "Please select both primary and secondary series for comparison")
            return
            
        if primary_name == secondary_name:
            messagebox.showwarning("⚠️ Different Series Required", 
                                 "Please select different series for meaningful comparison")
            return
        
        # Update button to show progress
        original_text = self.run_button.cget("text")
        self.run_button.configure(text="🔄 Analyzing...", state="disabled")
        
        try:
            # Find series configs by name instead of ID
            primary_series = None
            secondary_series = None
            
            for config in self.series_configs.values():
                if config.name == primary_name:
                    primary_series = config
                elif config.name == secondary_name:
                    secondary_series = config
            
            if not primary_series or not secondary_series:
                messagebox.showerror("Error", "Could not find selected series configurations")
                return
            
            # Get file data
            primary_file = self.loaded_files.get(primary_series.file_id)
            secondary_file = self.loaded_files.get(secondary_series.file_id)
            
            if not primary_file or not secondary_file:
                messagebox.showerror("Error", "Could not find file data for selected series")
                return
            
            # Extract data
            primary_x, primary_y = primary_series.get_data(primary_file)
            secondary_x, secondary_y = secondary_series.get_data(secondary_file)
            
            # Map comparison type names to internal names
            comp_type_mapping = {
                "Smart Overlay": "Overlay",
                "Side-by-Side": "Side-by-Side", 
                "Difference Analysis": "Difference",
                "Correlation Plot": "Correlation",
                "Statistical Summary": "Statistical",
                "Performance Comparison": "Statistical"
            }
            
            comparison_type = comp_type_mapping.get(self.comp_type_var.get(), "Overlay")
            
            # Map alignment names
            align_mapping = {
                "Auto-Detect": self._detect_best_alignment(primary_x, primary_y, secondary_x, secondary_y),
                "None": "None",
                "Start Times": "Start Times", 
                "Peak Alignment": "Peak Alignment",
                "Cross-Correlation": "Cross-Correlation",
                "Custom Offset": "None"  # TODO: Implement custom offset
            }
            
            time_align = align_mapping.get(self.time_align_var.get(), "None")
            
            # Perform enhanced comparison
            results = self.perform_series_comparison(
                primary_x, primary_y, secondary_x, secondary_y,
                primary_name, secondary_name, comparison_type, time_align
            )
            
            # Create intelligent visualization
            self.create_comparison_plot(
                primary_x, primary_y, secondary_x, secondary_y,
                primary_name, secondary_name, comparison_type, results
            )
            
            # Display comprehensive results
            self.display_comparison_results(results, primary_name, secondary_name, comparison_type)
            
            # Generate AI insights
            self._generate_insights(results, primary_name, secondary_name, comparison_type)
            
            # Switch to appropriate results tab
            if comparison_type in ["Overlay", "Side-by-Side"]:
                self.results_tabview.set("📈 Visualization")
            else:
                self.results_tabview.set("📊 Statistics")
            
        except Exception as e:
            messagebox.showerror("Analysis Error", f"Error in comparison analysis: {str(e)}")
            logger.error(f"Comparison analysis error: {e}")
        
        finally:
            # Restore button
            self.run_button.configure(text=original_text, state="normal")
    
    def _detect_best_alignment(self, x1, y1, x2, y2):
        """Intelligently detect the best alignment method"""
        try:
            # Check if series have similar time ranges
            t1_range = np.max(x1) - np.min(x1) 
            t2_range = np.max(x2) - np.min(x2)
            
            # Check for similar patterns (correlation-based)
            if len(y1) > 10 and len(y2) > 10:
                # Simple correlation check
                min_len = min(len(y1), len(y2))
                corr = np.corrcoef(y1[:min_len], y2[:min_len])[0, 1]
                
                if abs(corr) > 0.7:
                    return "Start Times"  # Similar patterns, align starts
                elif abs(corr) > 0.3:
                    return "Cross-Correlation"  # Some similarity, find best offset
                else:
                    return "Peak Alignment"  # Different patterns, align peaks
            
            # Default for short series
            return "Start Times"
            
        except Exception:
            return "None"
    
    def _generate_insights(self, results, primary_name, secondary_name, comparison_type):
        """Generate AI-like insights from comparison results"""
        insights = []
        
        try:
            # Header
            insights.append("🧠 INTELLIGENT ANALYSIS INSIGHTS")
            insights.append("=" * 50)
            insights.append("")
            
            # Basic comparison insights
            if 'series1_stats' in results and 'series2_stats' in results:
                s1 = results['series1_stats']
                s2 = results['series2_stats']
                
                # Mean comparison
                mean_diff_pct = ((s1['mean'] - s2['mean']) / s2['mean']) * 100 if s2['mean'] != 0 else 0
                if abs(mean_diff_pct) > 50:
                    insights.append(f"🔍 SIGNIFICANT DIFFERENCE: {primary_name} has {abs(mean_diff_pct):.1f}% {'higher' if mean_diff_pct > 0 else 'lower'} average values than {secondary_name}")
                elif abs(mean_diff_pct) > 10:
                    insights.append(f"📊 MODERATE DIFFERENCE: {mean_diff_pct:+.1f}% difference in average values")
                else:
                    insights.append(f"✅ SIMILAR AVERAGES: Both series have comparable mean values (±{abs(mean_diff_pct):.1f}%)")
                
                # Variability insights
                cv1 = s1['std'] / s1['mean'] if s1['mean'] != 0 else 0
                cv2 = s2['std'] / s2['mean'] if s2['mean'] != 0 else 0
                
                if cv1 > cv2 * 2:
                    insights.append(f"📈 VOLATILITY: {primary_name} is much more variable than {secondary_name}")
                elif cv2 > cv1 * 2:
                    insights.append(f"📈 VOLATILITY: {secondary_name} is much more variable than {primary_name}")
                else:
                    insights.append(f"📊 STABILITY: Both series show similar variability patterns")
                
                insights.append("")
            
            # Correlation insights
            if 'correlation' in results:
                corr = results['correlation']
                if abs(corr) > 0.8:
                    relationship = "STRONG" if corr > 0 else "STRONG INVERSE"
                    insights.append(f"🔗 {relationship} CORRELATION: R = {corr:.3f}")
                    insights.append(f"   The series move {'together' if corr > 0 else 'in opposite directions'} very consistently")
                elif abs(corr) > 0.5:
                    relationship = "MODERATE" if corr > 0 else "MODERATE INVERSE"  
                    insights.append(f"🔗 {relationship} CORRELATION: R = {corr:.3f}")
                    insights.append(f"   There's a noticeable {'positive' if corr > 0 else 'negative'} relationship")
                elif abs(corr) > 0.3:
                    insights.append(f"🔗 WEAK CORRELATION: R = {corr:.3f}")
                    insights.append(f"   Limited linear relationship between the series")
                else:
                    insights.append(f"🔗 NO LINEAR CORRELATION: R = {corr:.3f}")
                    insights.append(f"   The series appear to be independent or have non-linear relationships")
                
                insights.append("")
            
            # Statistical test insights
            if 'ttest' in results:
                p_val = results['ttest']['p_value']
                if p_val < 0.001:
                    insights.append(f"📊 HIGHLY SIGNIFICANT DIFFERENCE: p < 0.001")
                    insights.append(f"   Strong statistical evidence that the means differ")
                elif p_val < 0.05:
                    insights.append(f"📊 SIGNIFICANT DIFFERENCE: p = {p_val:.4f}")
                    insights.append(f"   Statistical evidence that the means differ")
                else:
                    insights.append(f"📊 NO SIGNIFICANT DIFFERENCE: p = {p_val:.4f}")
                    insights.append(f"   No strong evidence that the means differ statistically")
                
                insights.append("")
            
            # Vacuum-specific insights
            if 'vacuum_comparison' in results:
                vacuum = results['vacuum_comparison']
                insights.append("🔬 VACUUM SYSTEM INSIGHTS")
                insights.append("-" * 30)
                
                if 'base_pressure' in vacuum:
                    bp = vacuum['base_pressure']
                    ratio = bp['ratio']
                    if ratio > 10:
                        insights.append(f"🚨 LARGE BASE PRESSURE DIFFERENCE: {ratio:.1f}x difference")
                        insights.append(f"   {primary_name} may have significant leak or contamination issues")
                    elif ratio > 2:
                        insights.append(f"⚠️ MODERATE BASE PRESSURE DIFFERENCE: {ratio:.1f}x difference")
                        insights.append(f"   Consider checking pump efficiency and leak rates")
                    else:
                        insights.append(f"✅ SIMILAR BASE PRESSURES: {ratio:.1f}x difference")
                        insights.append(f"   Both systems achieve comparable ultimate vacuum")
                
                if 'stability' in vacuum:
                    better = vacuum['stability']['better']
                    insights.append(f"📊 STABILITY WINNER: {better}")
                    insights.append(f"   More stable pressure indicates better system control")
                
                insights.append("")
            
            # Recommendations
            insights.append("💡 RECOMMENDATIONS")
            insights.append("-" * 20)
            
            if comparison_type == "Overlay":
                insights.append("• Use 'Difference Analysis' to quantify point-by-point variations")
                insights.append("• Try 'Correlation Plot' to understand the relationship structure")
            elif comparison_type == "Correlation":
                insights.append("• Check 'Statistical Summary' for detailed hypothesis testing")
                insights.append("• Consider 'Performance Comparison' for vacuum-specific metrics")
            elif comparison_type == "Difference":
                insights.append("• Large differences may indicate different operating conditions")
                insights.append("• Check time alignment if patterns look similar but offset")
            
            # Add data quality insights
            insights.append("• Ensure both series represent comparable measurement conditions")
            insights.append("• Consider data preprocessing if noise levels differ significantly")
            
        except Exception as e:
            insights = [
                "🧠 INTELLIGENT ANALYSIS INSIGHTS",
                "=" * 50,
                "",
                f"⚠️ Could not generate insights: {str(e)}",
                "",
                "📊 Basic analysis completed successfully.",
                "Check the Statistics tab for detailed numerical results."
            ]
        
        # Display insights
        insights_text = "\n".join(insights)
        self.insights_text.delete("1.0", "end")
        self.insights_text.insert("1.0", insights_text)

    def perform_series_comparison(self, x1, y1, x2, y2, name1, name2, comp_type, time_align):
        """Perform detailed comparison analysis between two series"""
        results = {}
        
        # Basic statistics for both series
        results['series1_stats'] = {
            'mean': np.mean(y1),
            'std': np.std(y1),
            'min': np.min(y1),
            'max': np.max(y1),
            'count': len(y1)
        }
        
        results['series2_stats'] = {
            'mean': np.mean(y2),
            'std': np.std(y2),
            'min': np.min(y2),
            'max': np.max(y2),
            'count': len(y2)
        }
        
        # Time alignment if requested
        if time_align != "None":
            x1_aligned, y1_aligned, x2_aligned, y2_aligned = self.align_time_series(
                x1, y1, x2, y2, time_align
            )
            results['alignment_method'] = time_align
        else:
            x1_aligned, y1_aligned = x1, y1
            x2_aligned, y2_aligned = x2, y2
        
        # Interpolate to common time base for detailed comparison
        if comp_type in ["Difference", "Correlation", "Statistical"]:
            # Create common time base
            try:
                # Convert datetime to numeric if needed
                if pd.api.types.is_datetime64_any_dtype(x1_aligned):
                    x1_numeric = (pd.Series(x1_aligned) - pd.Series(x1_aligned).iloc[0]).dt.total_seconds()
                else:
                    x1_numeric = np.array(x1_aligned)
                    
                if pd.api.types.is_datetime64_any_dtype(x2_aligned):
                    x2_numeric = (pd.Series(x2_aligned) - pd.Series(x2_aligned).iloc[0]).dt.total_seconds()
                else:
                    x2_numeric = np.array(x2_aligned)
                
                t_min = max(np.min(x1_numeric), np.min(x2_numeric))
                t_max = min(np.max(x1_numeric), np.max(x2_numeric))
                
                if t_max > t_min:
                    common_time = np.linspace(t_min, t_max, 1000)
                    
                    # Interpolate both series to common time base
                    y1_interp = np.interp(common_time, x1_numeric, y1_aligned)
                    y2_interp = np.interp(common_time, x2_numeric, y2_aligned)
                    
                    results['common_time'] = common_time
                    results['y1_interpolated'] = y1_interp
                    results['y2_interpolated'] = y2_interp
                    
            except Exception as e:
                logger.warning(f"Failed to create common time base: {e}")
                # Skip interpolation-dependent analysis
                return results
                
                # Calculate correlation
                if len(y1_interp) > 1 and len(y2_interp) > 1:
                    correlation = np.corrcoef(y1_interp, y2_interp)[0, 1]
                    results['correlation'] = correlation
                
                # Calculate difference metrics
                diff = y1_interp - y2_interp
                results['difference_stats'] = {
                    'mean_diff': np.mean(diff),
                    'std_diff': np.std(diff),
                    'max_diff': np.max(np.abs(diff)),
                    'rms_diff': np.sqrt(np.mean(diff**2))
                }
                
                # Statistical tests
                try:
                    from scipy.stats import ttest_ind, ks_2samp
                    
                    # T-test for means
                    t_stat, t_pval = ttest_ind(y1_interp, y2_interp)
                    results['ttest'] = {'statistic': t_stat, 'p_value': t_pval}
                    
                    # Kolmogorov-Smirnov test for distributions
                    ks_stat, ks_pval = ks_2samp(y1_interp, y2_interp)
                    results['ks_test'] = {'statistic': ks_stat, 'p_value': ks_pval}
                    
                except ImportError:
                    logger.warning("scipy.stats not available for statistical tests")
        
        # Performance metrics comparison (if applicable for vacuum data)
        if 'pressure' in name1.lower() or 'vacuum' in name1.lower():
            results['vacuum_comparison'] = self.compare_vacuum_performance(
                x1_aligned, y1_aligned, x2_aligned, y2_aligned, name1, name2
            )
        
        return results

    def align_time_series(self, x1, y1, x2, y2, method):
        """Align time series using specified method"""
        if method == "Start Times":
            # Align start times to zero
            x1_aligned = x1 - x1[0]
            x2_aligned = x2 - x2[0]
            return x1_aligned, y1, x2_aligned, y2
            
        elif method == "Peak Alignment":
            # Align based on maximum values
            peak1_idx = np.argmax(y1)
            peak2_idx = np.argmax(y2)
            
            time_offset = x1[peak1_idx] - x2[peak2_idx]
            x2_aligned = x2 + time_offset
            
            return x1, y1, x2_aligned, y2
            
        elif method == "Cross-Correlation":
            # Align based on cross-correlation
            # Simplified implementation - could be enhanced
            correlation = np.correlate(y1, y2, mode='full')
            lag = np.argmax(correlation) - len(y2) + 1
            
            if lag > 0:
                x1_aligned = x1[lag:]
                y1_aligned = y1[lag:]
                x2_aligned = x2
                y2_aligned = y2
            else:
                x1_aligned = x1
                y1_aligned = y1
                x2_aligned = x2[-lag:]
                y2_aligned = y2[-lag:]
            
            return x1_aligned, y1_aligned, x2_aligned, y2_aligned
        
        return x1, y1, x2, y2

    def compare_vacuum_performance(self, x1, y1, x2, y2, name1, name2):
        """Compare vacuum-specific performance metrics"""
        comparison = {}
        
        try:
            # Base pressure comparison
            base1 = np.percentile(y1, 10)
            base2 = np.percentile(y2, 10)
            comparison['base_pressure'] = {
                name1: base1,
                name2: base2,
                'ratio': base1 / base2 if base2 != 0 else float('inf')
            }
            
            # Pressure stability comparison
            stability1 = np.std(y1) / np.mean(y1)
            stability2 = np.std(y2) / np.mean(y2)
            comparison['stability'] = {
                name1: stability1,
                name2: stability2,
                'better': name1 if stability1 < stability2 else name2
            }
            
            # Pump-down efficiency (if applicable)
            if len(y1) > 10 and len(y2) > 10:
                # Check for pump-down patterns
                log_y1 = np.log10(y1 + 1e-12)
                log_y2 = np.log10(y2 + 1e-12)
                
                # Calculate average pumping rates
                pump_rate1 = -np.mean(np.gradient(log_y1))
                pump_rate2 = -np.mean(np.gradient(log_y2))
                
                comparison['pump_efficiency'] = {
                    name1: pump_rate1,
                    name2: pump_rate2,
                    'better': name1 if pump_rate1 > pump_rate2 else name2
                }
        
        except Exception as e:
            logger.error(f"Error in vacuum performance comparison: {e}")
            comparison['error'] = str(e)
        
        return comparison

    def create_comparison_plot(self, x1, y1, x2, y2, name1, name2, comp_type, results):
        """Create comparison visualization"""
        # Clear previous plot
        for widget in self.comparison_plot_frame.winfo_children():
            widget.destroy()
        
        fig = Figure(figsize=(10, 8))
        
        if comp_type == "Overlay":
            ax = fig.add_subplot(111)
            ax.plot(x1, y1, label=name1, alpha=0.8)
            ax.plot(x2, y2, label=name2, alpha=0.8)
            ax.set_xlabel("Time")
            ax.set_ylabel("Value")
            ax.set_title(f"Overlay Comparison: {name1} vs {name2}")
            ax.legend()
            ax.grid(True, alpha=0.3)
            
        elif comp_type == "Side-by-Side":
            ax1 = fig.add_subplot(211)
            ax1.plot(x1, y1, label=name1, color='blue')
            ax1.set_title(name1)
            ax1.grid(True, alpha=0.3)
            
            ax2 = fig.add_subplot(212)
            ax2.plot(x2, y2, label=name2, color='orange')
            ax2.set_title(name2)
            ax2.set_xlabel("Time")
            ax2.grid(True, alpha=0.3)
            
        elif comp_type == "Difference" and 'common_time' in results:
            ax = fig.add_subplot(111)
            diff = results['y1_interpolated'] - results['y2_interpolated']
            ax.plot(results['common_time'], diff, label=f"{name1} - {name2}", color='red')
            ax.axhline(y=0, color='black', linestyle='--', alpha=0.5)
            ax.set_xlabel("Time")
            ax.set_ylabel("Difference")
            ax.set_title(f"Difference: {name1} - {name2}")
            ax.grid(True, alpha=0.3)
            
        elif comp_type == "Correlation" and 'y1_interpolated' in results:
            ax = fig.add_subplot(111)
            y1_interp = results['y1_interpolated']
            y2_interp = results['y2_interpolated']
            ax.scatter(y1_interp, y2_interp, alpha=0.6)
            
            # Add trend line
            if len(y1_interp) > 1:
                z = np.polyfit(y1_interp, y2_interp, 1)
                p = np.poly1d(z)
                ax.plot(y1_interp, p(y1_interp), "r--", alpha=0.8)
            
            ax.set_xlabel(name1)
            ax.set_ylabel(name2)
            ax.set_title(f"Correlation: {name1} vs {name2}")
            if 'correlation' in results:
                ax.text(0.05, 0.95, f"R = {results['correlation']:.3f}", 
                       transform=ax.transAxes, bbox=dict(boxstyle="round", facecolor="white"))
            ax.grid(True, alpha=0.3)
        
        fig.tight_layout()
        
        # Embed plot
        canvas = FigureCanvasTkAgg(fig, self.comparison_plot_frame)
        canvas.draw()
        canvas.get_tk_widget().pack(fill="both", expand=True)

    def display_comparison_results(self, results, name1, name2, comp_type):
        """Display comparison results in text area"""
        results_text = f"COMPARISON ANALYSIS\n"
        results_text += "=" * 50 + "\n\n"
        
        results_text += f"Primary Series: {name1}\n"
        results_text += f"Secondary Series: {name2}\n"
        results_text += f"Comparison Type: {comp_type}\n\n"
        
        # Basic statistics
        if 'series1_stats' in results and 'series2_stats' in results:
            s1 = results['series1_stats']
            s2 = results['series2_stats']
            
            results_text += "BASIC STATISTICS\n"
            results_text += "-" * 20 + "\n"
            results_text += f"{name1}:\n"
            results_text += f"  Mean: {s1['mean']:.6f}\n"
            results_text += f"  Std:  {s1['std']:.6f}\n"
            results_text += f"  Min:  {s1['min']:.6f}\n"
            results_text += f"  Max:  {s1['max']:.6f}\n\n"
            
            results_text += f"{name2}:\n"
            results_text += f"  Mean: {s2['mean']:.6f}\n"
            results_text += f"  Std:  {s2['std']:.6f}\n"
            results_text += f"  Min:  {s2['min']:.6f}\n"
            results_text += f"  Max:  {s2['max']:.6f}\n\n"
            
            # Relative differences
            results_text += "RELATIVE DIFFERENCES\n"
            results_text += "-" * 20 + "\n"
            if s2['mean'] != 0:
                mean_diff_pct = ((s1['mean'] - s2['mean']) / s2['mean']) * 100
                results_text += f"Mean difference: {mean_diff_pct:.2f}%\n"
            if s2['std'] != 0:
                std_diff_pct = ((s1['std'] - s2['std']) / s2['std']) * 100
                results_text += f"Std difference: {std_diff_pct:.2f}%\n"
            results_text += "\n"
        
        # Correlation
        if 'correlation' in results:
            results_text += "CORRELATION ANALYSIS\n"
            results_text += "-" * 20 + "\n"
            corr = results['correlation']
            results_text += f"Correlation coefficient: {corr:.4f}\n"
            if abs(corr) > 0.8:
                strength = "Strong"
            elif abs(corr) > 0.5:
                strength = "Moderate"
            elif abs(corr) > 0.3:
                strength = "Weak"
            else:
                strength = "Very weak"
            results_text += f"Correlation strength: {strength}\n\n"
        
        # Difference statistics
        if 'difference_stats' in results:
            diff = results['difference_stats']
            results_text += "DIFFERENCE ANALYSIS\n"
            results_text += "-" * 20 + "\n"
            results_text += f"Mean difference: {diff['mean_diff']:.6f}\n"
            results_text += f"Std of differences: {diff['std_diff']:.6f}\n"
            results_text += f"Max absolute difference: {diff['max_diff']:.6f}\n"
            results_text += f"RMS difference: {diff['rms_diff']:.6f}\n\n"
        
        # Statistical tests
        if 'ttest' in results:
            ttest = results['ttest']
            results_text += "STATISTICAL TESTS\n"
            results_text += "-" * 20 + "\n"
            results_text += f"T-test p-value: {ttest['p_value']:.6f}\n"
            if ttest['p_value'] < 0.05:
                results_text += "Means are significantly different (p < 0.05)\n"
            else:
                results_text += "Means are not significantly different (p ≥ 0.05)\n"
        
        if 'ks_test' in results:
            ks = results['ks_test']
            results_text += f"K-S test p-value: {ks['p_value']:.6f}\n"
            if ks['p_value'] < 0.05:
                results_text += "Distributions are significantly different (p < 0.05)\n"
            else:
                results_text += "Distributions are not significantly different (p ≥ 0.05)\n"
            results_text += "\n"
        
        # Vacuum-specific comparison
        if 'vacuum_comparison' in results:
            vacuum = results['vacuum_comparison']
            results_text += "VACUUM PERFORMANCE\n"
            results_text += "-" * 20 + "\n"
            
            if 'base_pressure' in vacuum:
                bp = vacuum['base_pressure']
                results_text += f"Base pressure ratio: {bp['ratio']:.2f}\n"
                better_base = name1 if bp[name1] < bp[name2] else name2
                results_text += f"Better base pressure: {better_base}\n"
            
            if 'stability' in vacuum:
                stab = vacuum['stability']
                results_text += f"Better stability: {stab['better']}\n"
            
            if 'pump_efficiency' in vacuum:
                pump = vacuum['pump_efficiency']
                results_text += f"Better pump efficiency: {pump['better']}\n"
        
        self.comparison_results.delete("1.0", "end")
        self.comparison_results.insert("1.0", results_text)

    def export_comparison_results(self):
        """Export comparison results to file"""
        try:
            file_path = filedialog.asksaveasfilename(
                defaultextension=".txt",
                filetypes=[("Text files", "*.txt"), ("All files", "*.*")],
                title="Export Comparison Results"
            )
            
            if file_path:
                content = self.comparison_results.get("1.0", "end-1c")
                with open(file_path, 'w') as f:
                    f.write(content)
                messagebox.showinfo("Success", f"Results exported to {file_path}")
                
        except Exception as e:
            messagebox.showerror("Error", f"Failed to export results: {str(e)}")

    def _run_statistical_analysis(self):
        """Run statistical analysis on selected series"""
        series_name = self.stat_series_var.get()
        if not series_name:
            messagebox.showwarning("Warning", "Please select a series")
            return

        # Find series
        series = None
        for s in self.series_configs.values():
            if s.name == series_name:
                series = s
                break

        if not series:
            return

        # Get data
        file_data = self.loaded_files.get(series.file_id)
        if not file_data:
            return

        x_data, y_data = series.get_data(file_data)

        # Run analysis
        stats = self.statistical_analyzer.calculate_basic_stats(y_data)
        normality = self.statistical_analyzer.test_normality(y_data)
        outliers = self.statistical_analyzer.detect_outliers(y_data)

        # Display results
        results = f"STATISTICAL ANALYSIS: {series_name}\n"
        results += "=" * 50 + "\n\n"

        results += "Basic Statistics:\n"
        results += f"  Count: {stats['count']}\n"
        results += f"  Mean: {stats['mean']:.6f}\n"
        results += f"  Median: {stats['median']:.6f}\n"
        results += f"  Std Dev: {stats['std']:.6f}\n"
        results += f"  Min: {stats['min']:.6f}\n"
        results += f"  Max: {stats['max']:.6f}\n"
        results += f"  Skewness: {stats['skewness']:.3f}\n"
        results += f"  Kurtosis: {stats['kurtosis']:.3f}\n\n"

        results += "Normality Test:\n"
        results += f"  Is Normal: {normality['is_normal']}\n"
        results += f"  Shapiro p-value: {normality['shapiro_p']:.6f}\n\n"

        results += "Outlier Detection:\n"
        outlier_count = len(outliers) if isinstance(outliers, list) else 0
        total_count = len(y_data)
        outlier_percentage = (outlier_count / total_count * 100) if total_count > 0 else 0
        results += f"  Outliers Found: {outlier_count}\n"
        results += f"  Percentage: {outlier_percentage:.2f}%\n"

        self.stat_results.delete("1.0", "end")
        self.stat_results.insert("1.0", results)

    def _run_base_pressure_analysis(self):
        """Run base pressure analysis"""
        series_name = self.base_series_var.get()
        if not series_name:
            messagebox.showwarning("Warning", "Please select a series")
            return

        # Find series
        series = None
        for s in self.series_configs.values():
            if s.name == series_name:
                series = s
                break

        if not series:
            return

        # Get data
        file_data = self.loaded_files.get(series.file_id)
        if not file_data:
            return

        x_data, y_data = series.get_data(file_data)
        window_size = self.window_size_var.get()

        # Run analysis
        result = self.vacuum_analyzer.calculate_base_pressure(
        y_data, window_size)
        
        # Handle different return types
        if isinstance(result, tuple):
            base_pressure, rolling_min, rolling_std = result
        else:
            base_pressure = result
            rolling_min = rolling_std = None

        # Store result
        self.vacuum_results['base_pressure'] = result

        # Display results
        text = f"BASE PRESSURE ANALYSIS: {series_name}\n"
        text += "=" * 50 + "\n\n"
        
        if isinstance(result, tuple):
            base_pressure = result[0]
            stability = result[1] if len(result) > 1 else 0.0
        else:
            base_pressure = result
            stability = 0.0
            
        text += f"Base Pressure: {base_pressure:.2e} mbar\n"
        text += f"Stability: {stability:.2e} mbar\n"
        text += f"Analysis Window: {window_size} minutes\n"

        self.base_text.delete(1.0, tk.END)
        self.base_text.insert(1.0, text)

    def _detect_spikes(self):
        """Detect pressure spikes"""
        series_name = self.spike_series_var.get()
        if not series_name:
            messagebox.showwarning("Warning", "Please select a series")
            return

        # Find series
        series = None
        for s in self.series_configs.values():
            if s.name == series_name:
                series = s
                break

        if not series:
            return

        # Get data
        file_data = self.loaded_files.get(series.file_id)
        if not file_data:
            return

        x_data, y_data = series.get_data(file_data)
        threshold = self.spike_threshold_var.get()

        # Detect spikes
        spikes = self.vacuum_analyzer.detect_spikes(y_data, threshold)

        # Clear previous results
        for item in self.spikes_tree.get_children():
            self.spikes_tree.delete(item)

        # Add to treeview
        for i, spike in enumerate(spikes):
            self.spikes_tree.insert("", "end", values=(
                i + 1,
                spike['start_time'],
                spike['end_time'],
                spike['duration'],
                f"{spike['max_pressure']:.2e}",
                spike['severity']
            ))

        # Store result
        self.vacuum_results['spikes'] = spikes

    def _detect_leaks(self):
        """Detect vacuum leaks"""
        series_name = self.leak_series_var.get()
        if not series_name:
            messagebox.showwarning("Warning", "Please select a series")
            return

        # Find series
        series = None
        for s in self.series_configs.values():
            if s.name == series_name:
                series = s
                break

        if not series:
            return

        # Get data
        file_data = self.loaded_files.get(series.file_id)
        if not file_data:
            return

        x_data, y_data = series.get_data(file_data)

        # Detect leaks
        leaks = self.vacuum_analyzer.detect_leaks(y_data)

        # Display results
        text = f"LEAK DETECTION: {series_name}\n"
        text += "=" * 50 + "\n\n"

        if leaks:
            text += f"Detected {len(leaks)} potential leaks:\n\n"
            for i, leak in enumerate(leaks):
                text += f"Leak #{i + 1}:\n"
                text += f"  Start: {leak['start']}\n"
                text += f"  End: {leak['end']}\n"
                text += f"  Leak Rate: {leak['rate']:.2e} mbar·L/s\n"
                text += f"  Confidence: {leak['confidence']:.1f}%\n\n"
        else:
            text += "No leaks detected\n"

        self.leak_text.delete(1.0, tk.END)
        self.leak_text.insert(1.0, text)

        # Store result
        self.vacuum_results['leaks'] = leaks

    def _analyze_pumpdown(self):
        """Analyze pump-down characteristics"""
        series_name = self.pump_series_var.get()
        if not series_name:
            messagebox.showwarning("Warning", "Please select a series")
            return

        # Find series
        series = None
        for s in self.series_configs.values():
            if s.name == series_name:
                series = s
                break

        if not series:
            return

        # Get data
        file_data = self.loaded_files.get(series.file_id)
        if not file_data:
            return

        x_data, y_data = series.get_data(file_data)

        # Analyze pump-down
        result = self.vacuum_analyzer.analyze_pumpdown(y_data)

        # Display results
        text = f"PUMP-DOWN ANALYSIS: {series_name}\n"
        text += "=" * 50 + "\n\n"
        text += f"Initial Pressure: {result['initial_pressure']:.2e} mbar\n"
        text += f"Final Pressure: {result['final_pressure']:.2e} mbar\n"
        text += f"Time Constant: {result['time_constant']:.1f} seconds\n"
        text += f"Pump-down Rate: {result['pumpdown_rate']:.2e} mbar/s\n"

        self.pump_text.delete(1.0, tk.END)
        self.pump_text.insert(1.0, text)

        # Store result
        self.vacuum_results['pumpdown'] = result

    def _export_results(self):
        """Export analysis results"""
        filename = filedialog.asksaveasfilename(
            title="Export Results",
            defaultextension=".txt",
            filetypes=[("Text Files", "*.txt"), ("All Files", "*.*")]
        )

        if filename:
            try:
                with open(filename, 'w') as f:
                    # Export current tab's results
                    active_tab = self.notebook.index(self.notebook.select())

                    if active_tab == 0:  # Statistical
                        f.write(self.stat_results.get(1.0, tk.END))
                    elif active_tab == 1:  # Vacuum
                        # Determine which vacuum sub-tab is active
                        vacuum_tab = self.notebook.nametowidget(self.notebook.select())
                        if "Base Pressure" in vacuum_tab.winfo_children()[0].winfo_name():
                            f.write(self.base_text.get(1.0, tk.END))
                        elif "Spike" in vacuum_tab.winfo_children()[0].winfo_name():
                            # Export spike data
                            f.write("Spike Detection Results\n")
                            f.write("=" * 50 + "\n")
                            for item in self.spikes_tree.get_children():
                                values = self.spikes_tree.item(item, 'values')
                                f.write(f"Spike {values[0]}: Start={values[1]}, End={values[2]}, "
                                        f"Duration={values[3]}, Max={values[4]}, Severity={values[5]}\n")
                        elif "Leak" in vacuum_tab.winfo_children()[0].winfo_name():
                            f.write(self.leak_text.get(1.0, tk.END))
                        elif "Pump-down" in vacuum_tab.winfo_children()[0].winfo_name():
                            f.write(self.pump_text.get(1.0, tk.END))

                    messagebox.showinfo("Success", f"Results exported to {filename}")
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export: {str(e)}")


class AnnotationDialog:
    """Dialog for managing plot annotations - Enhanced with Legacy Features"""

    def __init__(self, parent, annotation_manager, axes):
        self.parent = parent
        self.annotation_manager = annotation_manager
        self.axes = axes
        self.changed = False

        # Create dialog
        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Annotation Manager")
        self.dialog.geometry("1000x700")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Create UI
        self._create_widgets()

        # Load existing annotations
        self._refresh_annotation_list()

    def _create_widgets(self):
        """Create dialog widgets with legacy enhancements"""
        # Main container
        main_frame = ttk.Frame(self.dialog)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Paned window for split view
        paned = ttk.PanedWindow(main_frame, orient=tk.HORIZONTAL)
        paned.pack(fill="both", expand=True)

        # Left panel - Annotation tools
        left_panel = ttk.Frame(paned)
        paned.add(left_panel, weight=1)

        # Right panel - Annotation list and properties
        right_panel = ttk.Frame(paned)
        paned.add(right_panel, weight=2)

        # Create tools notebook
        self._create_tools_notebook(left_panel)

        # Create annotation list and properties
        self._create_annotation_list(right_panel)
        self._create_properties_panel(right_panel)

        # Buttons
        self._create_buttons()

    def _create_tools_notebook(self, parent):
        """Create annotation tools notebook"""
        notebook = ttk.Notebook(parent)
        notebook.pack(fill="both", expand=True, padx=5, pady=5)

        # Basic annotations tab
        basic_tab = ttk.Frame(notebook)
        notebook.add(basic_tab, text="Basic")
        self._create_basic_tools(basic_tab)

        # Data points tab
        data_tab = ttk.Frame(notebook)
        notebook.add(data_tab, text="Data Points")
        self._create_data_point_tools(data_tab)

        # Templates tab
        templates_tab = ttk.Frame(notebook)
        notebook.add(templates_tab, text="Templates")
        self._create_template_tools(templates_tab)

    def _create_basic_tools(self, parent):
        """Create basic annotation tools"""
        frame = ttk.LabelFrame(parent, text="Basic Annotations")
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        buttons = [
            ("Horizontal Line", self._add_horizontal_line),
            ("Vertical Line", self._add_vertical_line),
            ("Rectangle Region", self._add_region),
            ("Text Label", self._add_text),
            ("Arrow", self._add_arrow),
            ("Point", self._add_point)
        ]

        for text, command in buttons:
            btn = ttk.Button(frame, text=text, command=command)
            btn.pack(fill="x", padx=5, pady=2)

    def _create_data_point_tools(self, parent):
        """Create data point annotation tools"""
        frame = ttk.LabelFrame(parent, text="Data Point Annotations")
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        # Data point selection
        entry_frame = ttk.Frame(frame)
        entry_frame.pack(fill="x", padx=5, pady=5)

        ttk.Label(entry_frame, text="X:").pack(side="left")
        self.data_x_var = tk.StringVar()
        ttk.Entry(entry_frame, textvariable=self.data_x_var, width=10).pack(side="left", padx=5)

        ttk.Label(entry_frame, text="Y:").pack(side="left")
        self.data_y_var = tk.StringVar()
        ttk.Entry(entry_frame, textvariable=self.data_y_var, width=10).pack(side="left", padx=5)

        ttk.Button(
            frame,
            text="Add Data Point",
            command=self._add_data_point
        ).pack(fill="x", padx=5, pady=5)

    def _create_template_tools(self, parent):
        """Create template annotation tools"""
        frame = ttk.LabelFrame(parent, text="Annotation Templates")
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        templates = [
            ("Base Pressure Line", self._add_base_pressure_template),
            ("Pressure Targets", self._add_pressure_targets),
            ("Process Regions", self._add_process_regions),
            ("Critical Points", self._add_critical_points)
        ]

        for text, command in templates:
            btn = ttk.Button(frame, text=text, command=command)
            btn.pack(fill="x", padx=5, pady=2)

    def _create_annotation_list(self, parent):
        """Create annotation list panel"""
        frame = ttk.LabelFrame(parent, text="Annotations")
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        # Annotation listbox
        self.annotation_listbox = tk.Listbox(frame, selectmode="single")
        self.annotation_listbox.pack(side="left", fill="both", expand=True, padx=5, pady=5)
        self.annotation_listbox.bind("<<ListboxSelect>>", self._on_select_annotation)

        # Scrollbar
        scrollbar = ttk.Scrollbar(frame, command=self.annotation_listbox.yview)
        scrollbar.pack(side="right", fill="y")
        self.annotation_listbox.config(yscrollcommand=scrollbar.set)

        # Add buttons
        button_frame = ttk.Frame(frame)
        button_frame.pack(fill="x", padx=5, pady=5)

        ttk.Button(
            button_frame,
            text="+ Add",
            command=self._add_annotation,
            width=10
        ).pack(side="left", padx=2)

        ttk.Button(
            button_frame,
            text="- Remove",
            command=self._remove_annotation,
            width=10
        ).pack(side="left", padx=2)

        ttk.Button(
            button_frame,
            text="Clear All",
            command=self._clear_all,
            width=10
        ).pack(side="left", padx=2)

    def _create_properties_panel(self, parent):
        """Create properties panel"""
        frame = ttk.LabelFrame(parent, text="Properties")
        frame.pack(fill="both", expand=True, padx=5, pady=5)

        self.properties_frame = ttk.Frame(frame)
        self.properties_frame.pack(fill="both", expand=True, padx=5, pady=5)

        # Placeholder for dynamic properties
        ttk.Label(self.properties_frame, text="Select an annotation to edit properties").pack(pady=20)

    def _create_buttons(self):
        """Create dialog buttons"""
        button_frame = ttk.Frame(self.dialog)
        button_frame.pack(fill="x", pady=10)

        ttk.Button(
            button_frame,
            text="Apply",
            command=self._apply,
            width=10
        ).pack(side="right", padx=5)

        ttk.Button(
            button_frame,
            text="Close",
            command=self.dialog.destroy,
            width=10
        ).pack(side="right", padx=5)

    def _refresh_annotation_list(self):
        """Refresh the annotation list"""
        self.annotation_listbox.delete(0, tk.END)

        for ann in self.annotation_manager.get_annotations():
            display_text = f"{ann.type}: {ann.label}" if hasattr(ann, 'label') and ann.label else f"{ann.type}"
            self.annotation_listbox.insert(tk.END, display_text)

    def _on_select_annotation(self, event):
        """Handle annotation selection"""
        selection = self.annotation_listbox.curselection()
        if not selection:
            return

        # Get selected annotation
        index = selection[0]
        annotations = self.annotation_manager.get_annotations()

        if index < len(annotations):
            self._show_properties(annotations[index])

    def _show_properties(self, annotation: AnnotationConfig):
        """Show annotation properties"""
        # Clear previous properties
        for widget in self.properties_frame.winfo_children():
            widget.destroy()

        # Type
        frame = ttk.Frame(self.properties_frame)
        frame.pack(fill="x", pady=5)
        ttk.Label(frame, text="Type:").pack(side="left", padx=5)
        ttk.Label(frame, text=annotation.type).pack(side="left", padx=5)

        # Label
        frame = ttk.Frame(self.properties_frame)
        frame.pack(fill="x", pady=5)
        ttk.Label(frame, text="Label:").pack(side="left", padx=5)
        label_entry = ttk.Entry(frame, width=20)
        label_entry.insert(0, annotation.label)
        label_entry.pack(side="left", padx=5)

        # Color
        frame = ttk.Frame(self.properties_frame)
        frame.pack(fill="x", pady=5)
        ttk.Label(frame, text="Color:").pack(side="left", padx=5)
        color_button = ctk.CTkButton(
            frame,
            text="",
            width=3,
            fg_color=annotation.color
        )
        color_button.pack(side="left", padx=5)

        # Position fields based on type
        if annotation.type in ["line", "point"]:
            if annotation.x_data is not None:
                frame = ttk.Frame(self.properties_frame)
                frame.pack(fill="x", pady=5)
                ttk.Label(frame, text="X Position:").pack(side="left", padx=5)
                ttk.Label(frame, text=str(annotation.x_data)).pack(side="left", padx=5)

            if annotation.y_data is not None:
                frame = ttk.Frame(self.properties_frame)
                frame.pack(fill="x", pady=5)
                ttk.Label(frame, text="Y Position:").pack(side="left", padx=5)
                ttk.Label(frame, text=str(annotation.y_data)).pack(side="left", padx=5)

    def _add_annotation(self):
        """Add new annotation"""
        # Simple dialog for annotation type
        types = ["line", "region", "text", "arrow", "point"]

        # Create simple selection dialog
        dialog = tk.Toplevel(self.dialog)
        dialog.title("Add Annotation")
        dialog.geometry("300x400")
        dialog.transient(self.dialog)
        dialog.grab_set()

        ttk.Label(dialog, text="Select Type:", font=("", 12)).pack(pady=10)

        selected_type = tk.StringVar(value="line")

        for ann_type in types:
            ttk.Radiobutton(
                dialog,
                text=ann_type.capitalize(),
                variable=selected_type,
                value=ann_type
            ).pack(pady=5)

        def create_annotation():
            ann_type = selected_type.get()

            # Create default annotation based on type
            if ann_type == "line":
                ann = AnnotationConfig(
                    type="line",
                    label="Vertical Line",
                    x_data=0
                )
            elif ann_type == "region":
                ann = AnnotationConfig(
                    type="region",
                    label="Region",
                    x_data=0,
                    x_end=1
                )
            elif ann_type == "text":
                ann = AnnotationConfig(
                    type="text",
                    label="Text",
                    text="Annotation",
                    x_data=0,
                    y_data=0
                )
            elif ann_type == "arrow":
                ann = AnnotationConfig(
                    type="arrow",
                    label="Arrow",
                    x_data=0,
                    y_data=0,
                    x_end=1,
                    y_end=1
                )
            else:  # point
                ann = AnnotationConfig(
                    type="point",
                    label="Point",
                    x_data=0,
                    y_data=0
                )

            self.annotation_manager.add_annotation(ann)
            self._refresh_annotation_list()
            self.changed = True
            dialog.destroy()

        ttk.Button(
            dialog,
            text="Create",
            command=create_annotation,
            width=10
        ).pack(pady=20)

        ttk.Button(
            dialog,
            text="Cancel",
            command=dialog.destroy,
            width=10
        ).pack()

    def _add_horizontal_line(self):
        """Add horizontal line annotation"""
        ann = AnnotationConfig(
            type="hline",
            label="Horizontal Line",
            y_data=0.5
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_vertical_line(self):
        """Add vertical line annotation"""
        ann = AnnotationConfig(
            type="vline",
            label="Vertical Line",
            x_data=0.5
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_region(self):
        """Add region annotation"""
        ann = AnnotationConfig(
            type="region",
            label="Region",
            x_data=0.2,
            x_end=0.8
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_text(self):
        """Add text annotation"""
        ann = AnnotationConfig(
            type="text",
            label="Text",
            text="Annotation",
            x_data=0.5,
            y_data=0.5
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_arrow(self):
        """Add arrow annotation"""
        ann = AnnotationConfig(
            type="arrow",
            label="Arrow",
            x_data=0.2,
            y_data=0.2,
            x_end=0.8,
            y_end=0.8
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_point(self):
        """Add point annotation"""
        ann = AnnotationConfig(
            type="point",
            label="Point",
            x_data=0.5,
            y_data=0.5
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_data_point(self):
        """Add data point annotation"""
        try:
            x = float(self.data_x_var.get())
            y = float(self.data_y_var.get())

            ann = AnnotationConfig(
                type="point",
                label=f"Data Point ({x},{y})",
                x_data=x,
                y_data=y
            )
            self.annotation_manager.add_annotation(ann)
            self._refresh_annotation_list()
            self.changed = True
        except ValueError:
            messagebox.showerror("Error", "Invalid X or Y value")

    def _add_base_pressure_template(self):
        """Add base pressure line template"""
        ann = AnnotationConfig(
            type="hline",
            label="Base Pressure",
            y_data=0.1,
            color="green",
            line_style="--"
        )
        self.annotation_manager.add_annotation(ann)
        self._refresh_annotation_list()
        self.changed = True

    def _add_pressure_targets(self):
        """Add pressure target lines"""
        targets = [
            (1e-3, "High Vacuum", "blue"),
            (1e-6, "Ultra-High Vacuum", "green"),
            (1e-9, "Extreme High Vacuum", "purple")
        ]

        for pressure, label, color in targets:
            ann = AnnotationConfig(
                type="hline",
                label=label,
                y_data=pressure,
                color=color,
                line_style=":"
            )
            self.annotation_manager.add_annotation(ann)

        self._refresh_annotation_list()
        self.changed = True

    def _add_process_regions(self):
        """Add process region templates"""
        regions = [
            (0.1, 0.3, "Pump-down", "green"),
            (0.4, 0.6, "Process", "blue"),
            (0.7, 0.9, "Venting", "orange")
        ]

        for start, end, label, color in regions:
            ann = AnnotationConfig(
                type="region",
                label=label,
                x_data=start,
                x_end=end,
                color=color,
                alpha=0.2
            )
            self.annotation_manager.add_annotation(ann)

        self._refresh_annotation_list()
        self.changed = True

    def _add_critical_points(self):
        """Add critical point markers"""
        points = [
            (0.3, 0.8, "Peak", "red", "^"),
            (0.5, 0.2, "Valley", "blue", "v"),
            (0.7, 0.5, "Anomaly", "orange", "D")
        ]

        for x, y, label, color, marker in points:
            ann = AnnotationConfig(
                type="point",
                label=label,
                x_data=x,
                y_data=y,
                color=color,
                marker=marker,
                size=100
            )
            self.annotation_manager.add_annotation(ann)

        self._refresh_annotation_list()
        self.changed = True

    def _remove_annotation(self):
        """Remove selected annotation"""
        selection = self.annotation_listbox.curselection()
        if not selection:
            return

        index = selection[0]
        annotations = list(self.annotation_manager.get_annotations().keys())

        if index < len(annotations):
            self.annotation_manager.remove_annotation(annotations[index])
            self._refresh_annotation_list()
            self.changed = True

    def _clear_all(self):
        """Clear all annotations"""
        if messagebox.askyesno("Confirm", "Remove all annotations?"):
            self.annotation_manager.clear_annotations()
            self._refresh_annotation_list()
            self.changed = True

    def _apply(self):
        """Apply changes and close"""
        self.dialog.destroy()


class DataPreviewDialog:
    """Dialog for previewing data files"""

    def __init__(self, parent, file_data: FileData):
        self.file_data = file_data

        # Create dialog
        self.dialog = tk.Toplevel(parent)
        self.dialog.title(f"Data Preview: {file_data.filename}")
        self.dialog.geometry("900x600")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Create notebook
        notebook = ttk.Notebook(self.dialog)
        notebook.pack(fill="both", expand=True, padx=10, pady=10)

        # Data tab
        data_tab = ttk.Frame(notebook)
        self.notebook.add("📊 Data")
        self._create_data_tab(data_tab)

        # Info tab
        info_tab = ttk.Frame(notebook)
        self.notebook.add("ℹ️ Info")
        self._create_info_tab(info_tab)

        # Statistics tab
        stats_tab = ttk.Frame(notebook)
        self.notebook.add("📈 Statistics")
        self._create_stats_tab(stats_tab)

        # Close button
        ctk.CTkButton(
            self.dialog,
            text="Close",
            command=self.dialog.destroy,
            width=100
        ).pack(pady=10)

    def _create_data_tab(self, parent):
        """Create data preview tab"""
        # Create treeview for data display
        tree_frame = ttk.Frame(parent)
        tree_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Scrollbars
        v_scroll = ttk.Scrollbar(tree_frame, orient="vertical")
        h_scroll = ttk.Scrollbar(tree_frame, orient="horizontal")

        # Treeview
        columns = list(self.file_data.data.columns)
        tree = ttk.Treeview(
            tree_frame,
            columns=columns,
            show="tree headings",
            yscrollcommand=v_scroll.set,
            xscrollcommand=h_scroll.set
        )

        # Configure scrollbars
        v_scroll.config(command=tree.yview)
        h_scroll.config(command=tree.xview)

        # Pack components
        tree.grid(row=0, column=0, sticky="nsew")
        v_scroll.grid(row=0, column=1, sticky="ns")
        h_scroll.grid(row=1, column=0, sticky="ew")

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        # Configure columns
        tree.heading("#0", text="Index")
        tree.column("#0", width=60)

        for col in columns:
            tree.heading(col, text=col)
            tree.column(col, width=100)

        # Add data (limited to first 1000 rows)
        df_preview = self.file_data.data.head(1000)
        for idx, row in df_preview.iterrows():
            tree.insert("", "end", text=str(idx), values=list(row))

    def _create_info_tab(self, parent):
        """Create file info tab"""
        info_frame = ctk.CTkScrollableFrame(parent)
        info_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # File information
        info_data = [
            ("File Path", self.file_data.filepath),
            ("File Name", self.file_data.filename),
            ("Load Time", self.file_data.load_time.strftime("%Y-%m-%d %H:%M:%S")),
            ("Rows", f"{self.file_data.metadata['rows']:,}"),
            ("Columns", str(self.file_data.metadata['columns'])),
            ("Memory Usage", f"{self.file_data.metadata['memory_usage']:,} bytes"),
            ("Has Datetime", "Yes" if self.file_data.metadata['has_datetime'] else "No"),
            ("Has Numeric", "Yes" if self.file_data.metadata['has_numeric'] else "No")
        ]

        for label, value in info_data:
            frame = ctk.CTkFrame(info_frame)
            frame.pack(fill="x", pady=5)

            ctk.CTkLabel(
                frame,
                text=f"{label}:",
                font=("", 12, "bold"),
                width=150,
                anchor="w"
            ).pack(side="left", padx=10)

            ctk.CTkLabel(
                frame,
                text=str(value),
                anchor="w"
            ).pack(side="left", padx=10)

        # Column types
        ctk.CTkLabel(
            info_frame,
            text="Column Types:",
            font=("", 14, "bold")
        ).pack(pady=(20, 10))

        for col, dtype in self.file_data.metadata['dtypes'].items():
            frame = ctk.CTkFrame(info_frame)
            frame.pack(fill="x", pady=2)

            ctk.CTkLabel(
                frame,
                text=col,
                width=200,
                anchor="w"
            ).pack(side="left", padx=10)

            ctk.CTkLabel(
                frame,
                text=str(dtype),
                text_color="gray",
                anchor="w"
            ).pack(side="left", padx=10)

    def _create_stats_tab(self, parent):
        """Create statistics tab"""
        stats_frame = ctk.CTkScrollableFrame(parent)
        stats_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Get numeric columns
        numeric_cols = self.file_data.get_numeric_columns()

        if not numeric_cols:
            ctk.CTkLabel(
                stats_frame,
                text="No numeric columns found",
                font=("", 14),
                text_color="gray"
            ).pack(pady=50)
            return

        # Display statistics for each numeric column
        for col in numeric_cols[:10]:  # Limit to first 10 columns
            # Column header
            header = ctk.CTkFrame(stats_frame)
            header.pack(fill="x", pady=(10, 5))

            ctk.CTkLabel(
                header,
                text=col,
                font=("", 12, "bold")
            ).pack(side="left", padx=10)

            # Get column statistics
            stats = self.file_data.get_column_stats(col)

            # Display stats
            stats_text = (
                f"Mean: {stats['mean']:.3f} | "
                f"Median: {stats['median']:.3f} | "
                f"Std: {stats['std']:.3f} | "
                f"Min: {stats['min']:.3f} | "
                f"Max: {stats['max']:.3f}"
            )

            ctk.CTkLabel(
                stats_frame,
                text=stats_text,
                text_color="gray",
                anchor="w"
            ).pack(fill="x", padx=20, pady=2)

            # Separator
            ttk.Separator(stats_frame, orient="horizontal").pack(fill="x", pady=5)


class PlotConfigDialog:
    """Comprehensive plot configuration dialog"""

    def __init__(self, parent, plot_config):
        """
        Initialize plot configuration dialog

        Args:
            parent: Parent window
            plot_config: Dictionary containing current plot configuration
        """
        self.parent = parent
        self.plot_config = plot_config.copy()  # Work with a copy
        self.result = None

        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Plot Configuration")
        self.dialog.geometry("800x600")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Modern styling
        self.setup_styles()

        self.create_widgets()
        self.dialog.geometry(f"+{parent.winfo_rootx() + 50}+{parent.winfo_rooty() + 50}")

    def setup_styles(self):
        """Configure ttk styles for modern appearance"""
        style = ttk.Style()
        style.theme_use('clam')

        # Configure colors
        style.configure('Title.TLabel', font=('Segoe UI', 12, 'bold'))
        style.configure('Heading.TLabel', font=('Segoe UI', 10, 'bold'))
        style.configure('Success.TButton', foreground='white')
        style.map('Success.TButton', background=[('active', '#059669'), ('!active', '#10B981')])

    def create_widgets(self):
        """Create the dialog interface"""
        # Create main notebook
        self.notebook = ttk.Notebook(self.dialog)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Create tabs
        self.create_general_tab()
        self.create_axes_tab()
        self.create_style_tab()
        self.create_data_tab()

        # Button frame
        btn_frame = ttk.Frame(self.dialog)
        btn_frame.pack(fill='x', padx=10, pady=10)

        ttk.Button(btn_frame, text="Cancel", command=self.cancel).pack(side='right', padx=5)
        ttk.Button(btn_frame, text="Apply", command=self.apply_config,
                   style='Success.TButton').pack(side='right', padx=5)
        ttk.Button(btn_frame, text="Reset Defaults", command=self.reset_defaults).pack(side='left')

    def create_general_tab(self):
        """Create general settings tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="General")

        # Title settings
        title_frame = ttk.LabelFrame(tab, text="Title", padding=10)
        title_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(title_frame, text="Title:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.title_var = tk.StringVar(value=self.plot_config.get('title', ''))
        ttk.Entry(title_frame, textvariable=self.title_var, width=50).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(title_frame, text="Size:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.title_size_var = tk.IntVar(value=self.plot_config.get('title_size', 16))
        ttk.Spinbox(title_frame, from_=8, to=32, textvariable=self.title_size_var, width=10).grid(row=0, column=3,
                                                                                                  padx=5, pady=5)

        # Figure size
        size_frame = ttk.LabelFrame(tab, text="Figure Size", padding=10)
        size_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(size_frame, text="Width:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.fig_width_var = tk.DoubleVar(value=self.plot_config.get('fig_width', 14))
        ttk.Spinbox(size_frame, from_=6, to=24, increment=0.5,
                    textvariable=self.fig_width_var, width=10).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(size_frame, text="Height:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.fig_height_var = tk.DoubleVar(value=self.plot_config.get('fig_height', 9))
        ttk.Spinbox(size_frame, from_=4, to=16, increment=0.5,
                    textvariable=self.fig_height_var, width=10).grid(row=0, column=3, padx=5, pady=5)

        ttk.Label(size_frame, text="DPI:").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.dpi_var = tk.IntVar(value=self.plot_config.get('dpi', 100))
        ttk.Spinbox(size_frame, from_=50, to=300, increment=50,
                    textvariable=self.dpi_var, width=10).grid(row=1, column=1, padx=5, pady=5)

    def create_axes_tab(self):
        """Create axes configuration tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Axes")

        # X-axis
        x_frame = ttk.LabelFrame(tab, text="X-Axis", padding=10)
        x_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(x_frame, text="Label:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.xlabel_var = tk.StringVar(value=self.plot_config.get('xlabel', 'X Axis'))
        ttk.Entry(x_frame, textvariable=self.xlabel_var, width=30).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(x_frame, text="Size:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.xlabel_size_var = tk.IntVar(value=self.plot_config.get('xlabel_size', 12))
        ttk.Spinbox(x_frame, from_=8, to=24, textvariable=self.xlabel_size_var, width=10).grid(row=0, column=3, padx=5,
                                                                                               pady=5)

        self.log_x_var = tk.BooleanVar(value=self.plot_config.get('log_scale_x', False))
        ttk.Checkbutton(x_frame, text="Logarithmic Scale", variable=self.log_x_var).grid(row=1, column=0, columnspan=2,
                                                                                         sticky='w', padx=5, pady=5)

        self.x_auto_var = tk.BooleanVar(value=self.plot_config.get('x_auto_scale', True))
        ttk.Checkbutton(x_frame, text="Auto Scale", variable=self.x_auto_var,
                        command=self.toggle_x_limits).grid(row=1, column=2, columnspan=2, sticky='w', padx=5, pady=5)

        ttk.Label(x_frame, text="Min:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.x_min_var = tk.StringVar(value=self.plot_config.get('x_min', ''))
        self.x_min_entry = ttk.Entry(x_frame, textvariable=self.x_min_var, width=15)
        self.x_min_entry.grid(row=2, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(x_frame, text="Max:").grid(row=2, column=2, sticky='w', padx=5, pady=5)
        self.x_max_var = tk.StringVar(value=self.plot_config.get('x_max', ''))
        self.x_max_entry = ttk.Entry(x_frame, textvariable=self.x_max_var, width=15)
        self.x_max_entry.grid(row=2, column=3, sticky='w', padx=5, pady=5)

        # Y-axis
        y_frame = ttk.LabelFrame(tab, text="Y-Axis", padding=10)
        y_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(y_frame, text="Label:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.ylabel_var = tk.StringVar(value=self.plot_config.get('ylabel', 'Y Axis'))
        ttk.Entry(y_frame, textvariable=self.ylabel_var, width=30).grid(row=0, column=1, padx=5, pady=5)

        ttk.Label(y_frame, text="Size:").grid(row=0, column=2, sticky='w', padx=5, pady=5)
        self.ylabel_size_var = tk.IntVar(value=self.plot_config.get('ylabel_size', 12))
        ttk.Spinbox(y_frame, from_=8, to=24, textvariable=self.ylabel_size_var, width=10).grid(row=0, column=3, padx=5,
                                                                                               pady=5)

        self.log_y_var = tk.BooleanVar(value=self.plot_config.get('log_scale_y', False))
        ttk.Checkbutton(y_frame, text="Logarithmic Scale", variable=self.log_y_var).grid(row=1, column=0, columnspan=2,
                                                                                         sticky='w', padx=5, pady=5)

        self.y_auto_var = tk.BooleanVar(value=self.plot_config.get('y_auto_scale', True))
        ttk.Checkbutton(y_frame, text="Auto Scale", variable=self.y_auto_var,
                        command=self.toggle_y_limits).grid(row=1, column=2, columnspan=2, sticky='w', padx=5, pady=5)

        ttk.Label(y_frame, text="Min:").grid(row=2, column=0, sticky='w', padx=5, pady=5)
        self.y_min_var = tk.StringVar(value=self.plot_config.get('y_min', ''))
        self.y_min_entry = ttk.Entry(y_frame, textvariable=self.y_min_var, width=15)
        self.y_min_entry.grid(row=2, column=1, sticky='w', padx=5, pady=5)

        ttk.Label(y_frame, text="Max:").grid(row=2, column=2, sticky='w', padx=5, pady=5)
        self.y_max_var = tk.StringVar(value=self.plot_config.get('y_max', ''))
        self.y_max_entry = ttk.Entry(y_frame, textvariable=self.y_max_var, width=15)
        self.y_max_entry.grid(row=2, column=3, sticky='w', padx=5, pady=5)

        self.toggle_x_limits()
        self.toggle_y_limits()

    def create_style_tab(self):
        """Create visual style settings tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Style")

        # Grid settings
        grid_frame = ttk.LabelFrame(tab, text="Grid", padding=10)
        grid_frame.pack(fill='x', padx=10, pady=10)

        self.show_grid_var = tk.BooleanVar(value=self.plot_config.get('show_grid', True))
        ttk.Checkbutton(grid_frame, text="Show Grid", variable=self.show_grid_var).grid(row=0, column=0, sticky='w',
                                                                                        padx=5, pady=5)

        ttk.Label(grid_frame, text="Style:").grid(row=0, column=1, sticky='w', padx=5, pady=5)
        self.grid_style_var = tk.StringVar(value=self.plot_config.get('grid_style', '-'))
        ttk.Combobox(grid_frame, textvariable=self.grid_style_var,
                     values=['-', '--', ':', '-.'], width=10).grid(row=0, column=2, padx=5, pady=5)

        ttk.Label(grid_frame, text="Alpha:").grid(row=0, column=3, sticky='w', padx=5, pady=5)
        self.grid_alpha_var = tk.DoubleVar(value=self.plot_config.get('grid_alpha', 0.3))
        ttk.Scale(grid_frame, from_=0.1, to=1.0, variable=self.grid_alpha_var,
                  orient='horizontal', length=150).grid(row=0, column=4, padx=5, pady=5)

        # Legend
        legend_frame = ttk.LabelFrame(tab, text="Legend", padding=10)
        legend_frame.pack(fill='x', padx=10, pady=10)

        self.show_legend_var = tk.BooleanVar(value=self.plot_config.get('show_legend', True))
        ttk.Checkbutton(legend_frame, text="Show Legend", variable=self.show_legend_var).grid(row=0, column=0,
                                                                                              sticky='w', padx=5,
                                                                                              pady=5)

        ttk.Label(legend_frame, text="Location:").grid(row=0, column=1, sticky='w', padx=5, pady=5)
        self.legend_loc_var = tk.StringVar(value=self.plot_config.get('legend_location', 'best'))
        ttk.Combobox(legend_frame, textvariable=self.legend_loc_var,
                     values=['best', 'upper right', 'upper left', 'lower right', 'lower left', 'center'],
                     width=15).grid(row=0, column=2, padx=5, pady=5)

        # Margins
        margin_frame = ttk.LabelFrame(tab, text="Margins", padding=10)
        margin_frame.pack(fill='x', padx=10, pady=10)

        margins = [('Left', 'margin_left'), ('Right', 'margin_right'),
                   ('Top', 'margin_top'), ('Bottom', 'margin_bottom')]

        for i, (label, key) in enumerate(margins):
            ttk.Label(margin_frame, text=f"{label}:").grid(row=i // 2, column=(i % 2) * 2, sticky='w', padx=5, pady=5)
            var = tk.DoubleVar(value=self.plot_config.get(key, 0.1))
            setattr(self, f"{key}_var", var)
            ttk.Scale(margin_frame, from_=0.02, to=0.3, variable=var,
                      orient='horizontal', length=150).grid(row=i // 2, column=(i % 2) * 2 + 1, padx=5, pady=5)

    def create_data_tab(self):
        """Create data handling settings tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Data")

        # Problematic data handling
        prob_frame = ttk.LabelFrame(tab, text="Problematic Data Detection", padding=10)
        prob_frame.pack(fill='x', padx=10, pady=10)

        self.detect_zeros_var = tk.BooleanVar(value=self.plot_config.get('detect_zeros', True))
        ttk.Checkbutton(prob_frame, text="Highlight Zero Values",
                        variable=self.detect_zeros_var).grid(row=0, column=0, sticky='w', padx=5, pady=5)

        self.zero_color_var = tk.StringVar(value=self.plot_config.get('zero_color', 'red'))
        ttk.Label(prob_frame, text="Zero Color:").grid(row=0, column=1, sticky='w', padx=5, pady=5)
        ttk.Combobox(prob_frame, textvariable=self.zero_color_var,
                     values=['red', 'orange', 'yellow', 'purple'], width=10).grid(row=0, column=2, padx=5, pady=5)

        self.detect_outliers_var = tk.BooleanVar(value=self.plot_config.get('detect_outliers', True))
        ttk.Checkbutton(prob_frame, text="Highlight Outliers",
                        variable=self.detect_outliers_var).grid(row=1, column=0, sticky='w', padx=5, pady=5)

        self.outlier_threshold_var = tk.DoubleVar(value=self.plot_config.get('outlier_threshold', 3.0))
        ttk.Label(prob_frame, text="Outlier Threshold (σ):").grid(row=1, column=1, sticky='w', padx=5, pady=5)
        ttk.Spinbox(prob_frame, from_=1, to=10, increment=0.5,
                    textvariable=self.outlier_threshold_var, width=10).grid(row=1, column=2, padx=5, pady=5)

        self.detect_gaps_var = tk.BooleanVar(value=self.plot_config.get('detect_gaps', True))
        ttk.Checkbutton(prob_frame, text="Highlight Data Gaps",
                        variable=self.detect_gaps_var).grid(row=2, column=0, sticky='w', padx=5, pady=5)

        # Missing data handling
        missing_frame = ttk.LabelFrame(tab, text="Missing Data Handling", padding=10)
        missing_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(missing_frame, text="Method:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.missing_method_var = tk.StringVar(value=self.plot_config.get('missing_method', 'interpolate'))
        ttk.Combobox(missing_frame, textvariable=self.missing_method_var,
                     values=['interpolate', 'drop', 'fill_zero', 'forward_fill'],
                     width=15).grid(row=0, column=1, padx=5, pady=5)

        self.highlight_missing_var = tk.BooleanVar(value=self.plot_config.get('highlight_missing', True))
        ttk.Checkbutton(missing_frame, text="Highlight Missing Data",
                        variable=self.highlight_missing_var).grid(row=1, column=0, sticky='w', padx=5, pady=5)

        self.missing_color_var = tk.StringVar(value=self.plot_config.get('missing_color', 'gray'))
        ttk.Label(missing_frame, text="Missing Data Color:").grid(row=1, column=1, sticky='w', padx=5, pady=5)
        ttk.Combobox(missing_frame, textvariable=self.missing_color_var,
                     values=['gray', 'red', 'orange', 'purple'], width=10).grid(row=1, column=2, padx=5, pady=5)

    def toggle_x_limits(self):
        """Enable/disable X limit entries"""
        state = 'disabled' if self.x_auto_var.get() else 'normal'
        self.x_min_entry.config(state=state)
        self.x_max_entry.config(state=state)

    def toggle_y_limits(self):
        """Enable/disable Y limit entries"""
        state = 'disabled' if self.y_auto_var.get() else 'normal'
        self.y_min_entry.config(state=state)
        self.y_max_entry.config(state=state)

    def reset_defaults(self):
        """Reset to default configuration"""
        if messagebox.askyesno("Confirm", "Reset all settings to defaults?"):
            # Reset all variables to defaults
            self.title_var.set("Multi-File Data Analysis")
            self.title_size_var.set(16)
            self.fig_width_var.set(14)
            self.fig_height_var.set(9)
            self.dpi_var.set(100)

            self.xlabel_var.set("X Axis")
            self.xlabel_size_var.set(12)
            self.ylabel_var.set("Y Axis")
            self.ylabel_size_var.set(12)

            self.log_x_var.set(False)
            self.log_y_var.set(False)
            self.x_auto_var.set(True)
            self.y_auto_var.set(True)

            self.show_grid_var.set(True)
            self.grid_style_var.set('-')
            self.grid_alpha_var.set(0.3)
            self.show_legend_var.set(True)
            self.legend_loc_var.set('best')

            self.detect_zeros_var.set(True)
            self.detect_outliers_var.set(True)
            self.detect_gaps_var.set(True)

            self.toggle_x_limits()
            self.toggle_y_limits()

    def apply_config(self):
        """Apply configuration changes"""
        # Gather all settings
        self.plot_config = {
            'title': self.title_var.get(),
            'title_size': self.title_size_var.get(),
            'fig_width': self.fig_width_var.get(),
            'fig_height': self.fig_height_var.get(),
            'dpi': self.dpi_var.get(),

            'xlabel': self.xlabel_var.get(),
            'xlabel_size': self.xlabel_size_var.get(),
            'ylabel': self.ylabel_var.get(),
            'ylabel_size': self.ylabel_size_var.get(),

            'log_scale_x': self.log_x_var.get(),
            'log_scale_y': self.log_y_var.get(),
            'x_auto_scale': self.x_auto_var.get(),
            'y_auto_scale': self.y_auto_var.get(),

            'show_grid': self.show_grid_var.get(),
            'grid_style': self.grid_style_var.get(),
            'grid_alpha': self.grid_alpha_var.get(),
            'show_legend': self.show_legend_var.get(),
            'legend_location': self.legend_loc_var.get(),

            'margin_left': self.margin_left_var.get(),
            'margin_right': self.margin_right_var.get(),
            'margin_top': self.margin_top_var.get(),
            'margin_bottom': self.margin_bottom_var.get(),

            'detect_zeros': self.detect_zeros_var.get(),
            'zero_color': self.zero_color_var.get(),
            'detect_outliers': self.detect_outliers_var.get(),
            'outlier_threshold': self.outlier_threshold_var.get(),
            'detect_gaps': self.detect_gaps_var.get(),
            'missing_method': self.missing_method_var.get(),
            'highlight_missing': self.highlight_missing_var.get(),
            'missing_color': self.missing_color_var.get()
        }

        if not self.x_auto_var.get():
            self.plot_config['x_min'] = self.x_min_var.get()
            self.plot_config['x_max'] = self.x_max_var.get()

        if not self.y_auto_var.get():
            self.plot_config['y_min'] = self.y_min_var.get()
            self.plot_config['y_max'] = self.y_max_var.get()

        self.result = 'apply'
        self.dialog.destroy()

    def cancel(self):
        """Cancel without applying changes"""
        self.result = 'cancel'
        self.dialog.destroy()


class ExportDialog:
    """Dialog for exporting plots and data"""

    def __init__(self, parent, plot_manager):
        """
        Initialize export dialog

        Args:
            parent: Parent window
            plot_manager: PlotManager instance containing current plot and data
        """
        self.parent = parent
        self.plot_manager = plot_manager
        self.result = None

        self.dialog = tk.Toplevel(parent)
        self.dialog.title("Export Options")
        self.dialog.geometry("700x500")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Modern styling
        self.setup_styles()

        self.create_widgets()
        self.dialog.geometry(f"+{parent.winfo_rootx() + 50}+{parent.winfo_rooty() + 50}")

    def setup_styles(self):
        """Configure ttk styles for modern appearance"""
        style = ttk.Style()
        style.theme_use('clam')

        # Configure colors
        style.configure('Title.TLabel', font=('Segoe UI', 12, 'bold'))
        style.configure('Heading.TLabel', font=('Segoe UI', 10, 'bold'))
        style.configure('Success.TButton', foreground='white')
        style.map('Success.TButton', background=[('active', '#059669'), ('!active', '#10B981')])

    def create_widgets(self):
        """Create the dialog interface"""
        # Create main notebook
        self.notebook = ttk.Notebook(self.dialog)
        self.notebook.pack(fill='both', expand=True, padx=10, pady=10)

        # Create tabs
        self.create_plot_tab()
        self.create_data_tab()

        # Button frame
        btn_frame = ttk.Frame(self.dialog)
        btn_frame.pack(fill='x', padx=10, pady=10)

        ttk.Button(btn_frame, text="Cancel", command=self.cancel).pack(side='right', padx=5)
        ttk.Button(btn_frame, text="Export", command=self.export,
                   style='Success.TButton').pack(side='right', padx=5)

    def create_plot_tab(self):
        """Create plot export tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Plot Export")

        # Format selection
        format_frame = ttk.LabelFrame(tab, text="Export Format", padding=10)
        format_frame.pack(fill='x', padx=10, pady=10)

        self.format_var = tk.StringVar(value="PNG")
        formats = ["PNG", "JPEG", "SVG", "PDF", "TIFF"]

        for i, fmt in enumerate(formats):
            ttk.Radiobutton(format_frame, text=fmt, variable=self.format_var,
                            value=fmt).grid(row=i // 3, column=i % 3, padx=10, pady=5, sticky='w')

        # Resolution settings
        res_frame = ttk.LabelFrame(tab, text="Resolution", padding=10)
        res_frame.pack(fill='x', padx=10, pady=10)

        ttk.Label(res_frame, text="DPI:").grid(row=0, column=0, sticky='w', padx=5, pady=5)
        self.dpi_var = tk.IntVar(value=300)
        ttk.Spinbox(res_frame, from_=72, to=1200, textvariable=self.dpi_var, width=10).grid(row=0, column=1, padx=5,
                                                                                            pady=5)

        ttk.Label(res_frame, text="Width (inches):").grid(row=1, column=0, sticky='w', padx=5, pady=5)
        self.width_var = tk.DoubleVar(value=10)
        ttk.Spinbox(res_frame, from_=4, to=48, increment=0.5,
                    textvariable=self.width_var, width=10).grid(row=1, column=1, padx=5, pady=5)

        ttk.Label(res_frame, text="Height (inches):").grid(row=1, column=2, sticky='w', padx=5, pady=5)
        self.height_var = tk.DoubleVar(value=8)
        ttk.Spinbox(res_frame, from_=3, to=36, increment=0.5,
                    textvariable=self.height_var, width=10).grid(row=1, column=3, padx=5, pady=5)

        # Include elements
        elements_frame = ttk.LabelFrame(tab, text="Include Elements", padding=10)
        elements_frame.pack(fill='x', padx=10, pady=10)

        self.include_legend_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(elements_frame, text="Legend", variable=self.include_legend_var).grid(row=0, column=0, padx=5,
                                                                                              pady=5, sticky='w')

        self.include_title_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(elements_frame, text="Title", variable=self.include_title_var).grid(row=0, column=1, padx=5,
                                                                                            pady=5, sticky='w')

        self.include_grid_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(elements_frame, text="Grid", variable=self.include_grid_var).grid(row=0, column=2, padx=5,
                                                                                          pady=5, sticky='w')

        self.include_annotations_var = tk.BooleanVar(value=True)
        ttk.Checkbutton(elements_frame, text="Annotations", variable=self.include_annotations_var).grid(row=1, column=0,
                                                                                                        padx=5, pady=5,
                                                                                                        sticky='w')

        # File selection
        file_frame = ttk.LabelFrame(tab, text="Output File", padding=10)
        file_frame.pack(fill='x', padx=10, pady=10)

        self.file_path_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.file_path_var).pack(side='left', fill='x', expand=True, padx=5, pady=5)
        ttk.Button(file_frame, text="Browse", command=self.browse_plot_file).pack(side='right', padx=5, pady=5)

    def create_data_tab(self):
        """Create data export tab"""
        tab = ttk.Frame(self.notebook)
        self.notebook.add(tab, text="Data Export")

        # Format selection
        format_frame = ttk.LabelFrame(tab, text="Export Format", padding=10)
        format_frame.pack(fill='x', padx=10, pady=10)

        self.data_format_var = tk.StringVar(value="CSV")
        formats = ["CSV", "Excel", "JSON", "Parquet", "HDF5"]

        for i, fmt in enumerate(formats):
            ttk.Radiobutton(format_frame, text=fmt, variable=self.data_format_var,
                            value=fmt).grid(row=i // 3, column=i % 3, padx=10, pady=5, sticky='w')

        # Series selection
        series_frame = ttk.LabelFrame(tab, text="Series to Export", padding=10)
        series_frame.pack(fill='both', expand=True, padx=10, pady=10)

        # Create treeview for series selection
        columns = ('name', 'file', 'x_col', 'y_col')
        self.series_tree = ttk.Treeview(series_frame, columns=columns, show='headings', selectmode='extended')

        # Define headings
        self.series_tree.heading('name', text='Series Name')
        self.series_tree.heading('file', text='Data File')
        self.series_tree.heading('x_col', text='X Column')
        self.series_tree.heading('y_col', text='Y Column')

        # Set column widths
        self.series_tree.column('name', width=120)
        self.series_tree.column('file', width=120)
        self.series_tree.column('x_col', width=80)
        self.series_tree.column('y_col', width=80)

        # Add scrollbar
        scrollbar = ttk.Scrollbar(series_frame, orient='vertical', command=self.series_tree.yview)
        self.series_tree.configure(yscrollcommand=scrollbar.set)

        # Pack components
        self.series_tree.pack(side='left', fill='both', expand=True)
        scrollbar.pack(side='right', fill='y')

        # Populate with series
        for series_id, series in self.plot_manager.series_configs.items():
            file_name = self.plot_manager.loaded_files[series.file_id].filename
            self.series_tree.insert('', 'end', iid=series_id,
                                    values=(series.name, file_name, series.x_column, series.y_column),
                                    tags=('series',))

        # Select all by default
        for series_id in self.plot_manager.series_configs:
            self.series_tree.selection_add(series_id)

        # File selection
        file_frame = ttk.LabelFrame(tab, text="Output File", padding=10)
        file_frame.pack(fill='x', padx=10, pady=10)

        self.data_file_path_var = tk.StringVar()
        ttk.Entry(file_frame, textvariable=self.data_file_path_var).pack(side='left', fill='x', expand=True, padx=5,
                                                                         pady=5)
        ttk.Button(file_frame, text="Browse", command=self.browse_data_file).pack(side='right', padx=5, pady=5)

    def browse_plot_file(self):
        """Browse for plot export file"""
        file_types = [
            ('PNG files', '*.png'),
            ('JPEG files', '*.jpg;*.jpeg'),
            ('SVG files', '*.svg'),
            ('PDF files', '*.pdf'),
            ('TIFF files', '*.tif;*.tiff'),
            ('All files', '*.*')
        ]

        file_path = filedialog.asksaveasfilename(
            title="Save Plot As",
            defaultextension=".png",
            filetypes=file_types
        )

        if file_path:
            self.file_path_var.set(file_path)

    def browse_data_file(self):
        """Browse for data export file"""
        file_types = [
            ('CSV files', '*.csv'),
            ('Excel files', '*.xlsx'),
            ('JSON files', '*.json'),
            ('Parquet files', '*.parquet'),
            ('HDF5 files', '*.h5;*.hdf5'),
            ('All files', '*.*')
        ]

        file_path = filedialog.asksaveasfilename(
            title="Save Data As",
            defaultextension=".csv",
            filetypes=file_types
        )

        if file_path:
            self.data_file_path_var.set(file_path)

    def export(self):
        """Handle export process"""
        # Determine which tab is active
        if self.notebook.index(self.notebook.select()) == 0:  # Plot export tab
            self.export_plot()
        else:  # Data export tab
            self.export_data()

        self.result = 'export'
        self.dialog.destroy()

    def export_plot(self):
        """Export the plot"""
        file_path = self.file_path_var.get()
        if not file_path:
            messagebox.showerror("Error", "Please select an output file")
            return

        try:
            # Configure plot based on settings
            fig = self.plot_manager.figure
            fig.set_size_inches(self.width_var.get(), self.height_var.get())
            fig.set_dpi(self.dpi_var.get())

            # Toggle visibility of elements
            self.plot_manager.toggle_legend(self.include_legend_var.get())
            self.plot_manager.toggle_title(self.include_title_var.get())
            self.plot_manager.toggle_grid(self.include_grid_var.get())
            self.plot_manager.toggle_annotations(self.include_annotations_var.get())

            # Save the plot
            fig.savefig(file_path, bbox_inches='tight', dpi=self.dpi_var.get())

            # Restore original visibility
            self.plot_manager.toggle_legend(True)
            self.plot_manager.toggle_title(True)
            self.plot_manager.toggle_grid(True)
            self.plot_manager.toggle_annotations(True)

            messagebox.showinfo("Success", f"Plot exported to:\n{file_path}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export plot:\n{str(e)}")

    def export_data(self):
        """Export the data"""
        file_path = self.data_file_path_var.get()
        if not file_path:
            messagebox.showerror("Error", "Please select an output file")
            return

        selected_series = self.series_tree.selection()
        if not selected_series:
            messagebox.showerror("Error", "Please select at least one series to export")
            return

        try:
            # Collect all selected series data
            all_data = []
            for series_id in selected_series:
                series = self.plot_manager.series_configs[series_id]
                file_data = self.plot_manager.loaded_files[series.file_id]
                data = series.get_data(file_data)

                # Create DataFrame for this series
                df = pd.DataFrame({
                    'series': series.name,
                    'x': data[0],
                    'y': data[1]
                })
                all_data.append(df)

            # Combine all series data
            combined = pd.concat(all_data, ignore_index=True)

            # Export based on selected format
            export_format = self.data_format_var.get().lower()
            if export_format == 'csv':
                combined.to_csv(file_path, index=False)
            elif export_format == 'excel':
                combined.to_excel(file_path, index=False)
            elif export_format == 'json':
                combined.to_json(file_path, orient='records')
            elif export_format == 'parquet':
                combined.to_parquet(file_path)
            elif export_format == 'hdf5':
                combined.to_hdf(file_path, key='data', mode='w')

            messagebox.showinfo("Success", f"Data exported to:\n{file_path}")

        except Exception as e:
            messagebox.showerror("Error", f"Failed to export data:\n{str(e)}")

    def cancel(self):
        """Cancel without exporting"""
        self.result = 'cancel'
        self.dialog.destroy()

from ui.vacuum_analysis_dialog import VacuumAnalysisDialog as _CanonicalVacuumAnalysisDialog

class VacuumAnalysisDialog(_CanonicalVacuumAnalysisDialog):
    """Deprecated shim that forwards to ui.vacuum_analysis_dialog.VacuumAnalysisDialog.

    This consolidates duplicate Vacuum UI by preferring the dedicated dialog.
    """
    pass

    def export_results(self):
        """Export all analysis results"""
        filename = filedialog.asksaveasfilename(
            title="Export Vacuum Analysis Results",
            defaultextension=".txt",
            filetypes=[("Text files", "*.txt"), ("All files", "*.*")]
        )

        if filename:
            try:
                with open(filename, "w") as f:
                    f.write("VACUUM DATA ANALYSIS RESULTS\n")
                    f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
                    f.write("=" * 70 + "\n\n")

                    # Base pressure
                    if self.base_text.get(1.0, tk.END).strip():
                        f.write("BASE PRESSURE ANALYSIS\n")
                        f.write("-" * 70 + "\n")
                        f.write(self.base_text.get(1.0, tk.END))
                        f.write("\n\n")

                    # Leak detection
                    if self.leak_text.get(1.0, tk.END).strip():
                        f.write("LEAK DETECTION RESULTS\n")
                        f.write("-" * 70 + "\n")
                        f.write(self.leak_text.get(1.0, tk.END))
                        f.write("\n\n")

                    # Pump-down analysis
                    if self.pump_text.get(1.0, tk.END).strip():
                        f.write("PUMP-DOWN ANALYSIS\n")
                        f.write("-" * 70 + "\n")
                        f.write(self.pump_text.get(1.0, tk.END))
                        f.write("\n\n")

                messagebox.showinfo("Success", f"Analysis results exported to:\n{filename}")

            except Exception as e:
                messagebox.showerror("Error", f"Failed to export results:\n{str(e)}")


class DataSelectorDialog:
    """Dialog for advanced data selection from non-standard layouts"""

    def __init__(
            self,
            parent,
            file_data: FileData,
            on_data_selected: Optional[Callable] = None
    ):
        self.parent = parent
        self.file_data = file_data
        self.on_data_selected = on_data_selected
        self.result = None

        # Create dialog
        self.dialog = tk.Toplevel(parent)
        self.dialog.title(f"Data Selection: {file_data.filename}")
        self.dialog.geometry("800x600")
        self.dialog.transient(parent)
        self.dialog.grab_set()

        # Create UI
        self.create_widgets()

        # Center dialog
        self._center_dialog()

    def _center_dialog(self):
        """Center dialog on screen"""
        self.dialog.update_idletasks()
        x = (self.dialog.winfo_screenwidth() // 2) - (self.dialog.winfo_width() // 2)
        y = (self.dialog.winfo_screenheight() // 2) - (self.dialog.winfo_height() // 2)
        self.dialog.geometry(f"+{x}+{y}")

    def create_widgets(self):
        """Create dialog widgets"""
        # Preview section
        preview_frame = ctk.CTkFrame(self.dialog)
        preview_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Create treeview for data display
        tree_frame = ttk.Frame(preview_frame)
        tree_frame.pack(fill="both", expand=True)

        # Scrollbars
        v_scroll = ttk.Scrollbar(tree_frame, orient="vertical")
        h_scroll = ttk.Scrollbar(tree_frame, orient="horizontal")

        # Treeview
        columns = list(self.file_data.data.columns)
        self.tree = ttk.Treeview(
            tree_frame,
            columns=columns,
            show="tree headings",
            yscrollcommand=v_scroll.set,
            xscrollcommand=h_scroll.set
        )

        # Configure scrollbars
        v_scroll.config(command=self.tree.yview)
        h_scroll.config(command=self.tree.xview)

        # Pack components
        self.tree.grid(row=0, column=0, sticky="nsew")
        v_scroll.grid(row=0, column=1, sticky="ns")
        h_scroll.grid(row=1, column=0, sticky="ew")

        tree_frame.grid_rowconfigure(0, weight=1)
        tree_frame.grid_columnconfigure(0, weight=1)

        # Configure columns
        self.tree.heading("#0", text="Index")
        self.tree.column("#0", width=60)

        for col in columns:
            self.tree.heading(col, text=col)
            self.tree.column(col, width=100)

        # Add data (limited to first 1000 rows)
        df_preview = self.file_data.data.head(1000)
        for idx, row in df_preview.iterrows():
            self.tree.insert("", "end", text=str(idx), values=list(row))

        # Selection controls
        control_frame = ctk.CTkFrame(self.dialog)
        control_frame.pack(fill="x", padx=10, pady=10)

        # Header row selection
        ctk.CTkLabel(control_frame, text="Header Row:").grid(row=0, column=0, padx=5, pady=5)
        self.header_row_var = tk.IntVar(value=0)
        self.header_row_spin = ctk.CTkEntry(control_frame, textvariable=self.header_row_var, width=50)
        self.header_row_spin.grid(row=0, column=1, padx=5, pady=5)

        # Auto-detect button
        ctk.CTkButton(
            control_frame,
            text="Auto-Detect Headers",
            command=self.auto_detect_headers
        ).grid(row=0, column=2, padx=10, pady=5)

        # Data range
        ctk.CTkLabel(control_frame, text="Start Row:").grid(row=1, column=0, padx=5, pady=5)
        self.start_row_var = tk.IntVar(value=1)
        self.start_row_spin = ctk.CTkEntry(control_frame, textvariable=self.start_row_var, width=50)
        self.start_row_spin.grid(row=1, column=1, padx=5, pady=5)

        ctk.CTkLabel(control_frame, text="End Row:").grid(row=2, column=0, padx=5, pady=5)
        self.end_row_var = tk.IntVar(value=len(self.file_data.data))
        self.end_row_spin = ctk.CTkEntry(control_frame, textvariable=self.end_row_var, width=50)
        self.end_row_spin.grid(row=2, column=1, padx=5, pady=5)

        # Buttons
        button_frame = ctk.CTkFrame(self.dialog)
        button_frame.pack(fill="x", padx=10, pady=10)

        ctk.CTkButton(
            button_frame,
            text="Apply Selection",
            command=self.apply_selection,
            width=120
        ).pack(side="right", padx=5)

        ctk.CTkButton(
            button_frame,
            text="Cancel",
            command=self.dialog.destroy,
            width=100
        ).pack(side="right", padx=5)

    def auto_detect_headers(self):
        """Auto-detect header row"""
        # Use utility function to find header row
        header_row = detect_datetime_column(self.file_data.data)
        self.header_row_var.set(header_row)

        # Update start row
        self.start_row_var.set(header_row + 1)

    def apply_selection(self):
        """Apply data selection"""
        selection_info = {
            "header_row": self.header_row_var.get(),
            "start_row": self.start_row_var.get(),
            "end_row": self.end_row_var.get()
        }

        if self.on_data_selected:
            self.on_data_selected(selection_info)

        self.dialog.destroy()
